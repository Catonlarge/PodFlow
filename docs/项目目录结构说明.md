引入 **测试驱动开发 (TDD, Test-Driven Development)** 是一个非常高阶且专业的决定。

对于未来的 AI 产品经理来说，TDD 的意义不在于“写测试代码”，而在于**“在开发之前，先定义什么是‘成功’（Acceptance Criteria）”**。这与写 PRD（产品需求文档）的逻辑是完全互通的。

为了支持 TDD，我们需要在目录结构中显式地开辟“测试战场”。在 Python 后端通常使用 `pytest`，而在 React + Vite 前端通常使用 `Vitest`。

以下是为您重新整理的、包含完整测试架构的 **PodFlow 项目目录结构文档 (V2.0 - TDD版)**。

---

# 📂 PodFlow 项目目录结构规范 (V2.0 - TDD Ready)

### 1. 根目录概览 (Root)

> **设计逻辑：** 全局统一管理。

```text
PodFlow/
├── .gitignore          # [配置] 忽略 venv, node_modules, __pycache__, .pytest_cache
├── README.md           # [文档] 项目说明书
├── docs/               # [文档] 产品文档 (PRD, TDD测试用例设计)
├── backend/            # [后端] Python API 服务 (FastAPI)
└── frontend/           # [前端] React 界面 (Vite)

```

---

### 2. 后端目录详解 (Backend)

> **TDD 策略：** 使用 **pytest**。
> 测试文件夹独立于 `app` 代码之外，保持源码纯净。

```text
backend/
├── venv/                   # [环境] 虚拟环境
├── data/                   # [存储] 本地数据库与音频
├── app/                    # [源码] 业务逻辑
│   ├── __init__.py
│   ├── main.py             # FastAPI 入口
│   ├── api.py              # 路由定义
│   ├── models.py           # 数据库模型
│   └── services/           # 核心业务 (AI/文件操作)
│       ├── __init__.py
│       └── whisper_service.py
├── tests/                  # [测试] 🧪 TDD 的核心战场
│   ├── __init__.py
│   ├── conftest.py         # [配置] 测试夹具 (Fixture)，比如建立一个临时的测试数据库
│   ├── test_main.py        # [集成测试] 测试 API 接口通不通 (如 GET /)
│   ├── test_whisper.py     # [单元测试] 专门测试 Whisper 转录逻辑是否正确
│   └── test_db.py          # [单元测试] 测试数据库写入/读取是否正常
├── pytest.ini              # [配置] pytest 的配置文件
└── requirements.txt        # 依赖列表 (需加入 pytest, httpx)

```

**🔍 PM 视角解读 `tests/conftest.py`：**
这是 TDD 的神器。你可以在这里定义一个“假的数据库”或者“假的 AI 引擎”。运行测试时，程序会自动用假的替换真的，这样你就不用每次测试都真去调 OpenAI 或者污染真的数据库。

---

### 3. 前端目录详解 (Frontend)

> **TDD 策略：** 使用 **Vitest** + **React Testing Library**。
> Vite 天生支持 Vitest（因为它们是一个团队做的），配置极简。

```text
frontend/
├── node_modules/           # [依赖]
├── public/                 # [资源]
├── vite.config.js          # [配置] 需添加 test 配置段
├── setupTests.js           # [配置] 全局测试环境设置 (如模拟浏览器 DOM)
└── src/                    # [源码]
    ├── main.jsx
    ├── App.jsx
    ├── api.js
    ├── components/         # [组件]
    │   ├── __tests__/
    │   │   └── AudioPlayer.test.jsx  # [测试] 🧪 集成测试（保留核心集成测试用例）
    │   ├── common/                   # [通用组件] 基础UI组件
    │   │   ├── Icon.jsx              # SVG图标集中管理（占位）
    │   │   ├── Modal.jsx             # 通用弹窗容器（Portal实现，占位）
    │   │   └── Toast.jsx              # 错误/成功提示（占位）
    │   ├── layout/                    # [布局组件] 页面布局
    │   │   ├── MainLayout.jsx        # 主布局容器（占位）
    │   │   └── EpisodeHeader.jsx       # 播客信息头部（占位）
    │   ├── player/                    # [播放器组件] 音频播放相关（从AudioPlayer拆分）
    │   │   ├── __tests__/
    │   │   │   ├── AudioBarContainer.test.jsx  # [测试] 测试收缩/展开逻辑
    │   │   │   ├── FullAudioBar.test.jsx      # [测试] 测试完整控制条
    │   │   │   ├── MiniAudioBar.test.jsx      # [测试] 测试收缩态UI
    │   │   │   └── ProgressBar.test.jsx       # [测试] 测试进度条拖拽交互
    │   │   ├── AudioBarContainer.jsx  # 智能容器：检测鼠标，决定显示Full还是Mini
    │   │   ├── MiniAudioBar.jsx       # 收缩态UI：5px进度条线
    │   │   ├── FullAudioBar.jsx       # 展开态UI：包含所有按钮、音量、倍速（按钮不拆分）
    │   │   └── ProgressBar.jsx       # 进度条组件：独立拆分（拖拽交互逻辑复杂）
    │   ├── subtitles/                 # [字幕组件] 字幕展示与交互（占位）
    │   │   ├── SubtitleList.jsx       # 字幕列表容器（占位）
    │   │   ├── SubtitleRow.jsx        # 单行字幕组件（占位，性能优化边界，必须独立拆分）
    │   │   ├── SelectionMenu.jsx       # 划线菜单（占位，定位逻辑复杂）
    │   │   └── AICard.jsx             # AI查询卡片（占位，独立数据流）
    │   ├── notes/                     # [笔记组件] 笔记管理（占位）
    │   │   ├── NoteSidebar.jsx        # 笔记侧边栏（占位，包含笔记列表循环逻辑）
    │   │   └── NoteCard.jsx           # 笔记卡片（占位，包含展示态+编辑态+删除逻辑）
    │   └── upload/                    # [上传组件] 文件上传与识别（占位）
    │       ├── FileImportModal.jsx    # 文件选择弹窗（占位）
    │       └── ProcessingOverlay.jsx  # 进度遮罩（占位）
    ├── hooks/                         # [自定义Hooks] 业务逻辑提取
    │   ├── __tests__/
    │   │   ├── useAudio.test.js       # [测试] 测试音频播放逻辑
    │   │   ├── useIdle.test.js        # [测试] 测试无操作检测逻辑
    │   │   ├── useSubtitleSync.test.js # [测试] 测试字幕同步逻辑（占位）
    │   │   └── useTextSelection.test.js # [测试] 测试文本选择逻辑（占位）
    │   ├── useAudio.js                # 音频播放逻辑（从AudioPlayer提取）
    │   ├── useIdle.js                 # 鼠标无操作检测（从AudioPlayer提取）
    │   ├── useSubtitleSync.js         # 字幕同步逻辑（占位）
    │   └── useTextSelection.js        # 文本选择逻辑（占位，实现跨段落划线）
    ├── context/                       # [全局状态管理] Context API（占位）
    │   ├── AudioContext.jsx           # 音频状态上下文（占位）
    │   ├── SubtitleContext.jsx        # 字幕状态上下文（占位）
    │   └── NoteContext.jsx            # 笔记状态上下文（占位）
    ├── services/                      # [业务逻辑服务] API调用封装（占位）
    │   ├── audioService.js            # 音频相关API调用（占位）
    │   ├── subtitleService.js         # 字幕相关API调用（占位）
    │   └── noteService.js             # 笔记相关API调用（占位）
    ├── utils/                         # [工具函数]
    │   └── timeUtils.js               # 时间格式化（已存在）
    └── tests/                         # [测试] 🧪 集成测试/E2E测试（端到端）
        └── App.test.jsx               # 测试整个 App 页面能否正常渲染

```

**🔍 PM 视角解读前端测试结构：**

* **同级存放 (`AudioPlayer.test.jsx`)：** 适合**单元测试**。就像给每个零件（组件）贴个合格证。
* **独立存放 (`src/tests/`)：** 适合**集成测试**。就像把零件拼成车后，跑一圈看看散没散架。

**📋 组件拆分策略说明：**

采用**"逻辑聚合"策略**，遵循**"逻辑复杂度不够，就不配单独建文件"**原则：

* **不拆分细粒度组件**：Play/Pause/Skip/倍速/音量按钮直接写在`FullAudioBar.jsx`内部，因为逻辑简单（只是点击事件）
* **独立拆分复杂组件**：`ProgressBar.jsx`单独拆分，因为拖拽交互逻辑复杂（鼠标按下、拖拽中、松开、点击跳转、hover显示时间）
* **UI结构分离**：`MiniAudioBar.jsx`独立拆分，因为收缩态UI结构完全不同（5px进度条线 vs 完整控制条）
* **性能优化边界**：`SubtitleRow.jsx`必须独立拆分，因为字幕列表可能有1000+行，需要配合`React.memo`优化渲染性能
* **拒绝过度拆分**：
  - 笔记列表循环不拆分，直接写在`NoteSidebar.jsx`内部
  - 删除确认弹窗不拆分，使用通用的`Modal`组件
  - 通用按钮不拆分，直接使用原生HTML `<button>`配合CSS类名
  - 侧边栏切换按钮不拆分，直接写在`MainLayout.jsx`或`EpisodeHeader.jsx`中
  - 文本选择UI组件不拆分，跨段落划线逻辑由`hooks/useTextSelection.js`监听鼠标事件完成，UI组件只负责根据状态改变背景色

**🔗 组件依赖关系：**

```
AudioBarContainer (智能容器，整合useAudio和useIdle)
  ├── FullAudioBar (展开态UI，包含所有按钮，不拆分)
  │   └── ProgressBar (进度条组件，独立拆分，拖拽交互复杂)
  └── MiniAudioBar (收缩态UI，5px进度条线)
```

**📝 测试文件组织说明：**

* **Hooks测试** (`hooks/__tests__/`)：测试业务逻辑Hook，如`useAudio.test.js`测试音频播放逻辑，`useIdle.test.js`测试无操作检测逻辑
* **组件测试** (`components/player/__tests__/`)：测试各个UI组件，如`ProgressBar.test.jsx`测试进度条拖拽交互，`FullAudioBar.test.jsx`测试完整控制条
* **集成测试** (`components/__tests__/AudioPlayer.test.jsx`)：测试整个播放器系统的集成功能，验证各组件协同工作
* **E2E测试** (`tests/App.test.jsx`)：测试整个应用页面能否正常渲染

**🔍 PM 视角解读前端测试结构：**

* **同级存放 (`AudioPlayer.test.jsx`)：** 适合**单元测试**。就像给每个零件（组件）贴个合格证。
* **独立存放 (`src/tests/`)：** 适合**集成测试**。就像把零件拼成车后，跑一圈看看散没散架。

---


### 💡 TDD 工作流演示 (你的日常)

当你要开发“笔记保存功能”时，按照 TDD 流程，你应该这样做：

1. **Red (红灯 - 写一个会失败的测试):**
在 `backend/tests/test_notes.py` 里写一段代码：*“模拟发送一条笔记，断言数据库里能查到它。”*
此时运行测试 -> **报错**（因为你还没写功能代码）。
2. **Green (绿灯 - 写勉强能跑的代码):**
去 `backend/app/api.py` 快速写好保存笔记的接口。
此时运行测试 -> **通过**。
3. **Refactor (重构 - 优化代码):**
回头看代码写得太乱，整理一下格式，或者把逻辑抽离到 `services` 目录。
此时运行测试 -> **依然通过**（说明你没改坏东西）。

这就是**测试驱动开发**。现在的目录结构已经完全支持这种开发模式了。
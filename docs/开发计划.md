# PodFlow 项目开发计划

> **版本**: v1.0  
> **创建日期**: 2025-12-23  
> **项目目标**: 打造本地优先的 AI 播客学习工具

---

## 目录
- [一、数据库设计方案](#一数据库设计方案)
- [二、开发策略](#二开发策略)
- [三、原子任务拆分](#三原子任务拆分)
- [四、开发节奏](#四开发节奏)
- [五、关键技术决策](#五关键技术决策)

---

## 一、数据库设计方案
表格版本：
https://docs.google.com/document/d/1NFLItC1df_0fSSBD1SvNeDVP0aP3Ap4Gj645jEeMcBU/edit?usp=sharing

### 核心关联关系

```
Podcast (播客) 
  ↓ 1:N
Episode (单集/音频文件)
  ↓ 1:N
AudioSegment (音频虚拟分段) ← 新增！用于异步识别
  ↓ 1:N
TranscriptCue (字幕片段，含 speaker) ← 对应 PRD 的 cue
  ↓ 1:N
Highlight (用户划线)
  ↓ 1:1
Note (笔记：underline/thought/ai_query)
  ↓ 0:1
AIQueryRecord (AI 查询记录)
```

### 文件存储策略

**采用虚拟分段 + 临时文件方案**（存储优化：仅保留一份完整音频）

```
backend/data/
├── audios/                          # 原始完整音频（唯一存储）
│   ├── abc123def456.mp3             # 使用 MD5 hash 命名
│   └── 789ghi012jkl.mp3
└── transcripts/                     # 字幕文件（可选，JSON 格式）
    ├── abc123def456.json            # 全量字幕
    └── abc123def456/
        ├── segment_001.json         # 分段字幕缓存
        └── segment_002.json

说明：
- 不物理切割音频文件（节省 50% 存储空间）
- 转录时用 FFmpeg 提取片段到临时文件（/tmp/）
- 转录完成后自动删除临时文件
```

---

### 数据表设计

#### 1. Podcast（播客）
| 字段 | 类型 | 说明 |
|------|------|------|
| id | Integer | 主键 |
| title | String | 播客名称（如 "Lenny's Podcast"） |
| source_url | String | 原始链接（用户提供），**唯一索引** ⭐ |
| description | Text | 播客描述 |
| cover_image | String | 封面图片路径 |
| created_at | DateTime | 创建时间 |

**设计要点**：
- 本地音频可不关联 Podcast（`podcast_id` 可为空）
- **`source_url` 唯一性约束**：防止重复添加同一个播客源
- **允许同名 Podcast**：不同源的播客可以有相同的 title（如 "The Daily"）
- **去重逻辑**：添加 Podcast 前，先检查 source_url 是否已存在
- **NULL 值不受限制**：多个 Podcast 可以有 source_url=NULL（手动创建的播客）

**索引优化**：
```sql
CREATE UNIQUE INDEX idx_source_url ON podcasts(source_url);
CREATE INDEX idx_title ON podcasts(title);
```

---

#### 2. Episode（单集/音频文件）
| 字段 | 类型 | 说明 |
|------|------|------|
| id | Integer | 主键 |
| podcast_id | Integer | 外键 → Podcast（可为空，本地音频无 podcast） |
| **文件信息** | | |
| title | String | 单集标题 |
| original_filename | String | 用户上传的原始文件名 |
| original_path | String | 用户选择的原始路径（仅供参考） |
| audio_path | String | 项目内存储路径（实际使用） |
| file_hash | String | MD5 hash（唯一索引，用于去重） |
| file_size | Integer | 文件大小（字节） |
| duration | Float | 音频总时长（秒） |
| **转录状态** | | |
| transcription_status | String | 转录状态（pending/processing/completed/failed，用于高效查询） |
| **元数据** | | |
| language | String | 语言代码（默认 "en-US"） |
| created_at | DateTime | 创建时间 |
| updated_at | DateTime | 更新时间 |

**设计要点**：
- `file_hash` 用于去重：相同文件只存储一次
- `audio_path`：保存到项目目录，不依赖用户原始路径
- **存储策略**：只保留完整音频，不切割物理文件
- **❌ 删除分段相关字段**：`needs_segmentation`、`segment_duration`、`total_segments`
  - 理由：这些都是派生属性，改用 `@property` 动态计算
  - `segment_duration` 是全局配置（存储在 `config.py`），不是每个 Episode 独立设置
  - 大多数音频都需要分段，单独存储 `needs_segmentation` 意义不大
  - 便于实验：修改全局配置后，所有 Episode 自动使用新值
- **节目名称优化**（消除数据冗余）：
  - ❌ 删除 `show_name` 字段（避免与 Podcast.title 重复）
  - ✅ 使用 `@property` 动态获取：
    - 如果关联了 Podcast → 返回 `Podcast.title`
    - 如果是本地音频 → 返回 `"本地音频"`
  - ✅ 符合数据库第三范式（3NF），保证数据一致性
  - ✅ 使用 SQLAlchemy `joinedload` 优化查询性能

- **分段信息优化**（全局配置 + 动态计算）⭐ 新增：
  - ❌ 删除字段：`needs_segmentation`、`segment_duration`、`total_segments`
  - ✅ **分段阈值改为全局配置**（`backend/app/config.py`）：
    - `SEGMENT_DURATION = 180`（默认值，可调整）
    - 便于实验：修改配置后，所有 Episode 自动生效
    - 不需要更新数据库，重启服务即可
  - ✅ **使用 `@property` 动态计算**：
    ```python
    @property
    def segment_duration(self):
        """返回全局配置的分段时长"""
        from app.config import SEGMENT_DURATION
        return SEGMENT_DURATION
    
    @property
    def needs_segmentation(self):
        """是否需要分段（基于全局配置）"""
        return self.duration > self.segment_duration
    
    @property
    def total_segments(self):
        """总段数（动态计算）"""
        if not self.needs_segmentation:
            return 1
        import math
        return math.ceil(self.duration / self.segment_duration)
    ```
  - ✅ **设计原则**：
    - 大多数音频都需要分段，单独存储 `needs_segmentation` 没有意义
    - 分段阈值是系统级参数（非用户配置），应集中管理
    - 阈值需要频繁调整以找到最优值（平衡转录速度和用户体验）
    - 消除数据冗余，符合单一数据源原则

- **转录状态优化**（物理字段 + 动态属性双层设计）：
  - ✅ **物理字段 `transcription_status`**（用于高效查询）：
    - 存储状态值：`pending`/`processing`/`completed`/`failed`
    - 添加索引，支持高效查询（如筛选"所有已完成的单集"）
    - 避免全表扫描和 N+1 性能问题
    - 状态值由业务逻辑更新（不是从 AudioSegment 聚合，是独立的物理字段）
  - ✅ **动态属性**（仅供前端展示，不用于查询）：
    - `transcription_progress`: 返回百分比（0-100），用于进度条
    - `transcription_status_display`: 返回友好文本（"正在转录中..."/"转录完成"）
    - `estimated_time_remaining`: 返回预计剩余秒数（用户关心"还要等多久"）
    - **不暴露分段信息**：用户不需要知道"被切成几段"
  - ✅ **开发调试层**（完整技术数据）：
    - `transcription_stats`: 返回段数统计（total/completed/failed/processing/pending）
    - `failed_segments_detail`: 返回失败段的详细错误信息
    - **仅供日志、监控、调试使用**
  - ✅ 设计原则：
    - 物理字段用于查询（避免性能问题）
    - 动态属性用于展示（隐藏技术细节）
    - 数据源单一（Segment 状态为准），保证一致性

- **转录时间戳优化**（从 AudioSegment 聚合计算）⭐ 新增：
  - ❌ 删除数据库字段：`transcription_started_at`、`transcription_completed_at`
  - ✅ **改为 @property 动态计算**：
    - `transcription_started_at` = `min(segment.transcription_started_at)` （第一个开始转录的 Segment）
    - `transcription_completed_at` = `max(segment.recognized_at)` （所有 Segment 完成后才有值）
  - ✅ **理由**：
    - Episode 的时间戳与 AudioSegment 的时间戳存在**严格的逻辑依赖关系**
    - 存储冗余数据会导致**数据不一致风险**（Segment 重试后时间变化，Episode 时间可能未同步）
    - 违反**单一数据源原则**（AudioSegment 才是真实的数据来源）
  - ✅ **优势**：
    - 单一数据源（AudioSegment 为准），无冗余存储
    - 数据一致性保证：Segment 重试后，Episode 时间自动正确
    - 短音频（单 Segment）和长音频（多 Segments）逻辑统一
    - 自动更新：无需手动同步 Episode 和 Segment 的时间戳
  - ✅ **性能考虑**：
    - 使用 `joinedload` 预加载关联，避免 N+1 查询

**索引优化**：
```sql
CREATE UNIQUE INDEX idx_file_hash ON episodes(file_hash);
CREATE INDEX idx_podcast_id ON episodes(podcast_id);
CREATE INDEX idx_title ON episodes(title);
CREATE INDEX idx_transcription_status ON episodes(transcription_status);  -- 用于高效查询
```

---

#### 3. AudioSegment（音频虚拟分段）- 新增！
| 字段 | 类型 | 说明 |
|------|------|------|
| id | Integer | 主键 |
| episode_id | Integer | 外键 → Episode |
| **分段信息** | | |
| segment_index | Integer | 段序号（从 0 开始，**用于排序**）⭐ |
| segment_id | String | 分段 ID（如 "segment_001"） |
| segment_path | String | 临时音频文件路径（生命周期管理：pending=NULL / processing=路径 / completed=NULL / failed=保留） |
| **时间范围**（核心） | | |
| start_time | Float | 在原音频中的开始时间（秒） |
| end_time | Float | 在原音频中的结束时间（秒） |
| **识别状态** | | |
| status | String | pending/processing/completed/failed |
| error_message | Text | 错误信息 |
| retry_count | Integer | 重试次数（默认 0）⭐ 新增 |
| transcription_started_at | DateTime | 开始转录时间（用于排序和监控）⭐ 新增 |
| recognized_at | DateTime | 识别完成时间 |
| created_at | DateTime | 创建时间 |

**设计要点**：
- **虚拟分段**：只记录时间范围（`start_time`, `end_time`），不切割物理文件
- **❌ 删除 duration 字段**：改为 `@property` 动态计算（`end_time - start_time`），避免数据不一致
- **统一处理所有音频**（Critical）：
  - **短音频处理**（duration < SEGMENT_DURATION，如 150 秒）：
    - ✅ **也会创建 AudioSegment**（只创建 1 个）
    - `segment_index = 0`，`segment_id = "segment_000"`
    - `start_time = 0.0`，`end_time = episode.duration`（整个音频）
    - 所有 TranscriptCue 的 `segment_id` 都指向这个唯一的 segment
    - **理由**：统一转录流程、状态管理、重试机制，无需特殊判断
  - **长音频处理**（duration >= SEGMENT_DURATION，如 600 秒）：
    - 创建多个 AudioSegment（如 4 个）
    - `segment_index = 0, 1, 2, 3`，`segment_id = "segment_000", "segment_001", ...`
    - 每个 segment 覆盖 180 秒（最后一个可能不足）
  - **代码统一**：短音频和长音频走完全相同的转录流程，极大简化实现
- **临时文件生命周期管理**（`segment_path` 字段优化）：
  - **初始状态（pending）**：`segment_path = NULL`（未提取音频）
  - **转录开始**：FFmpeg 提取片段到持久临时文件（如 `backend/data/temp_segments/segment_001_abc123.wav`），记录路径到 `segment_path`
  - **转录成功（completed）**：删除临时文件，清空 `segment_path = NULL`
  - **转录失败（failed）**：保留临时文件和路径，重试时可直接使用（节省提取时间）
  - **定期清理**：孤儿临时文件（超过 30 分钟的失败转录）由后台任务清理
- **中断恢复**：服务器重启后，可根据 `segment_path` 继续转录（如果文件存在）
- **支持异步识别**：用户滚动时按需识别后续 segment
- **顺序保证**：`segment_index` 必须连续（0, 1, 2, 3...），用于保证分段顺序
- **重试机制**：`retry_count` 记录失败重试次数，便于监控和限制最大重试
- **删除冗余字段**：`cue_count` 删除（从 TranscriptCue 关联查询即可）、`duration` 删除（动态计算）

**索引优化**：
```sql
-- 按 episode 和 segment_index 排序（保证顺序）
CREATE INDEX idx_episode_segment ON audio_segments(episode_id, segment_index);
-- 按状态查询（用于监控和重试）
CREATE INDEX idx_segment_status ON audio_segments(status);
-- 复合索引（用于查询某个 episode 的待处理 segment）
CREATE INDEX idx_episode_status_segment ON audio_segments(episode_id, status, segment_index);
```

---

#### 4. TranscriptCue（字幕片段）
| 字段 | 类型 | 说明 |
|------|------|------|
| id | Integer | 主键 |
| episode_id | Integer | 外键 → Episode |
| segment_id | Integer | 外键 → AudioSegment（可选，CASCADE 删除） |
| **字幕内容**（对应 PRD 的 cue 结构） | | |
| start_time | Float | 开始时间戳（秒，用于排序） |
| end_time | Float | 结束时间戳（秒） |
| speaker | String | 说话人（如 "Lenny", "SPEAKER_01", "Unknown"） |
| text | Text | 字幕文本 |
| created_at | DateTime | 创建时间 |

**设计要点**：
- 对应 PRD 中的 `cue` 概念（不是 segment）
- `speaker` 字段：支持说话人标识（PRD 必需），默认 "Unknown"
- **移除 `cue_index` 字段**（⭐ 最终方案）：
  - **原因**：在异步/并发转录场景下，维护全局连续整数索引成本极高且易出错
  - **替代方案**：只存储 `start_time`，查询时使用 `ORDER BY start_time ASC` 获得正确顺序
  - **前端序号**：前端需要序号时，在内存中动态生成（Index + 1）
  - **性能优势**：避免重新索引的复杂逻辑和并发安全问题
- **`segment_id` 关联说明**（Critical）：
  - **正常转录场景**（`segment_id` 有值）：
    - **短音频**（如 150 秒）：所有 cue 的 `segment_id` 都指向唯一的 AudioSegment（segment_index=0）
    - **长音频**（如 600 秒）：不同 cue 的 `segment_id` 指向不同的 AudioSegment（按时间范围划分）
    - **示例**：
      ```python
      # 短音频（150 秒）
      Episode(id=1, duration=150)
        → AudioSegment(id=1, segment_index=0, start_time=0, end_time=150)
          → TranscriptCue(id=1, segment_id=1, start_time=0.28, text="First sentence")
          → TranscriptCue(id=2, segment_id=1, start_time=2.5, text="Second sentence")
          → TranscriptCue(id=3, segment_id=1, start_time=5.0, text="Third sentence")
      
      # 长音频（600 秒）
      Episode(id=2, duration=600)
        → AudioSegment(id=2, segment_index=0, start_time=0, end_time=180)
          → TranscriptCue(id=4, segment_id=2, start_time=0.5, text="...")
        → AudioSegment(id=3, segment_index=1, start_time=180, end_time=360)
          → TranscriptCue(id=5, segment_id=3, start_time=180.8, text="...")
      ```
  - **特殊场景**（`segment_id` 为 NULL）：
    - 手动导入字幕（用户上传 SRT/VTT 文件）
    - 手动编辑字幕（用户在界面手动添加/修改）
    - 历史数据迁移（从旧系统导入，没有 AudioSegment 记录）
  - **级联删除策略**：`segment_id` 改为 `CASCADE`（而非 `SET NULL`），防止重试转录后旧字幕残留
- **`start_time`/`end_time`**：相对于原始音频的绝对时间（⭐ 排序依据）
  - 这是保证字幕顺序的核心字段
  - 查询时使用 `ORDER BY start_time ASC` 获得正确顺序
  - 前端需要序号时，在内存中动态生成（Index + 1）
- **Highlight 关联**：使用 `cue.id`（主键），确保笔记与字幕的锚定永不漂移（⭐ Critical）
  - `cue.id` 是自增主键，一旦分配永不改变
  - 完全解决异步转录的关联问题
  - 笔记与字幕的关联稳定，不受排序方式影响

**PRD 字幕格式对应**：
```json
{
  "cues": [
    {
      "id": 0,                      → cue_index（从 1 开始更直观）
      "start": 0.28,                → start_time
      "end": 2.22,                  → end_time
      "speaker": "Lenny",           → speaker
      "text": "Thank you..."        → text
    }
  ]
}
```

**索引优化**：
```sql
-- 时间范围索引（用于排序和范围查询，主要查询索引）⭐
CREATE INDEX idx_episode_time ON transcript_cues(episode_id, start_time);
-- Segment 关联索引（用于异步识别）
CREATE INDEX idx_segment_cue ON transcript_cues(segment_id);
```

---

#### 5. Highlight（用户划线）- 简化设计：单 cue 关联 + 分组管理 ⭐
| 字段 | 类型 | 说明 |
|------|------|------|
| id | Integer | 主键 |
| episode_id | Integer | 外键 → Episode |
| **划线范围**（单 cue 关联）⭐ 简化 | | |
| cue_id | Integer | 外键 → TranscriptCue（只关联一个 cue）⭐ |
| start_offset | Integer | 在 cue 内的字符起始位置 |
| end_offset | Integer | 在 cue 内的字符结束位置 |
| **划线内容**（快照） | | |
| highlighted_text | Text | 被划线的文本内容（用于快速渲染） |
| **分组管理**（跨 cue 划线支持）⭐ 新增 | | |
| highlight_group_id | String | 分组 ID（UUID），同一次划线产生的多个 Highlight 共享（可为空：单 cue 划线时为 NULL）⭐ 优化 |
| **样式** | | |
| color | String | 划线颜色（默认 #9C27B0，紫色）⭐ 优化：数据库层面设置默认值 |
| **时间戳** ⭐ 新增 | | |
| created_at | DateTime | 创建时间 |
| updated_at | DateTime | 更新时间（支持修改颜色等操作）⭐ 新增 |

**设计要点**（Critical ⭐⭐⭐ - 简化设计，解决异步转录问题）：
- **核心变更**：不允许单个 Highlight 跨 cue，改为自动拆分 + 分组管理
- **字段优化**（⭐ 新增）：
  - `updated_at`：支持修改划线颜色、范围等操作，追踪最后修改时间
  - `color`：数据库层面设置默认值 `#9C27B0`（紫色），更健壮
  - `highlight_group_id`：明确为可空（`nullable=True`）
    - **单 cue 划线**（90% 场景）：`highlight_group_id = NULL`
    - **跨 cue 划线**（10% 场景）：`highlight_group_id = UUID`（同一次划线的多个 Highlight 共享）
- **用户体验**：
  - 用户划线时可以跨 cue（如跨多个句子）
  - 前端自动拆分成多个 Highlight（每个 cue 一个）
  - 使用 `highlight_group_id` 关联同一次划线产生的多个 Highlight
  - 用户完全无感知，看到的仍然是连续的高亮
- **实现逻辑**：
  ```javascript
  // 前端划线逻辑
  function handleTextSelection(selection) {
      const affectedCues = getAffectedCues(selection);
      
      if (affectedCues.length === 1) {
          // 单 cue 划线（90% 的情况）
          createHighlight({
              cue_id: affectedCues[0].id,
              start_offset: selection.startOffset,
              end_offset: selection.endOffset,
              highlight_group_id: null  // 单 cue 不需要分组
          });
      } else {
          // 跨 cue 划线（10% 的情况）
          const groupId = generateUUID();
          affectedCues.forEach((cue, index) => {
              createHighlight({
                  cue_id: cue.id,
                  start_offset: index === 0 ? selection.startOffset : 0,
                  end_offset: index === affectedCues.length - 1 ? selection.endOffset : cue.text.length,
                  highlight_group_id: groupId  // ⭐ 同一组
              });
          });
      }
  }
  ```
- **删除逻辑**：
  ```python
  # 删除 Highlight 时，按组删除
  if highlight.highlight_group_id:
      db.query(Highlight).filter(
          Highlight.highlight_group_id == highlight.highlight_group_id
      ).delete()
  else:
      db.delete(highlight)
  ```
- **优点**：
  - ✅ 极大简化设计：每个 Highlight 只关联一个 cue
  - ✅ 完全解决 cue_index 变化问题：使用 `cue.id`（主键）关联，永不变化
  - ✅ 前端渲染简单：每个 cue 独立渲染高亮
  - ✅ 符合 90% 的实际使用场景（单词/句子划线）
  - ✅ 通过分组管理仍然支持跨 cue 划线（用户无感知）
- **颜色默认紫色**（PRD 318行："被划线的字幕出现紫色下划线"）

**索引优化**：
```sql
-- Episode 级别的划线查询
CREATE INDEX idx_episode_highlight ON highlights(episode_id);
-- Cue 级别的划线查询（高频）
CREATE INDEX idx_highlight_cue ON highlights(cue_id);
-- 分组查询（用于按组删除和渲染）⭐ 新增
CREATE INDEX idx_highlight_group ON highlights(highlight_group_id);
-- 复合索引（提高查询性能）
CREATE INDEX idx_highlight_episode_cue ON highlights(episode_id, cue_id);
```

---

#### 6. Note（笔记）- 明确 AI 查询转化关系！
| 字段 | 类型 | 说明 |
|------|------|------|
| id | Integer | 主键 |
| episode_id | Integer | 外键 → Episode（CASCADE） |
| highlight_id | Integer | 外键 → Highlight（必需，CASCADE） |
| **来源追踪** ← 新增！ | | |
| origin_ai_query_id | Integer | 外键 → AIQueryRecord（可选，SET NULL）⭐ 优化 |
| **笔记内容** | | |
| content | Text | 笔记内容（underline 类型时为空，nullable=True）⭐ 优化 |
| note_type | String | underline/thought/ai_card（必需，无默认值）⭐ 优化 |
| **元数据** | | |
| created_at | DateTime | 创建时间 |
| updated_at | DateTime | 更新时间 |

**设计要点**（Critical - AI 查询与笔记的转化关系）：
- **字段优化说明**（⭐ 新增）：
  - `content`：`nullable=True`（underline 类型时为空）
  - `note_type`：`nullable=False`（必须显式指定类型，无默认值）
  - `origin_ai_query_id`：`nullable=True, ondelete="SET NULL"`（删除 AIQueryRecord 不影响 Note）
  - 级联删除：删除 Episode 或 Highlight 时，级联删除 Note（`ondelete="CASCADE"`）

- **`note_type` 三种类型**：
  - `underline`：纯划线（只有下划线样式，不显示笔记卡片，content 为空）
  - `thought`：用户想法（显示笔记卡片，用户手动输入）
  - **`ai_card`**：保存的 AI 查询结果（显示笔记卡片，来自 AI）← 修正命名！
  
- **AI 查询到笔记的转化逻辑**（PRD 6.2.4.e）：
  1. 用户划线 → 点击"AI 查询" → 创建 `AIQueryRecord`（临时）
  2. AI 返回结果 → 前端展示"AI查询卡片"（临时 UI）
    3. 用户点击卡片上的"笔记图标" → 创建 `Note`（持久化）：
     - `note_type = 'ai_card'`
     - `content = AIQueryRecord.response_text`（从 JSON 格式化为可读文本）⭐ 优化
     - `origin_ai_query_id = AIQueryRecord.id`（记录来源）
    4. 右侧笔记栏渲染所有 `Note` 表数据（不包括未保存的 AI 查询）

- **`origin_ai_query_id` 的作用**：
  - 追溯笔记来源：这条笔记是从哪次 AI 查询保存的
  - 避免重复查询：用户再次划同样的内容，可以直接从 `AIQueryRecord` 缓存加载
  - 数据分析：统计用户最常查询的词汇/短语
  - **数据独立性**：删除 AIQueryRecord 不影响 Note（通过 SET NULL 保证）

- **`highlight_id` 必需**：所有笔记都源于划线操作

- **笔记位置动态计算**：通过 `Note → Highlight → TranscriptCue` 关联链，在前端根据 Cue 的 DOM 位置（`offsetTop`）动态渲染笔记卡片（PRD 390行："笔记卡片的顶部在用户的'划线源'顶部上面24px的位置"）

**索引优化**：
```sql
-- 基础索引
CREATE INDEX idx_episode_note ON notes(episode_id);
CREATE INDEX idx_highlight_note ON notes(highlight_id);
CREATE INDEX idx_note_type ON notes(note_type);
CREATE INDEX idx_origin_ai_query ON notes(origin_ai_query_id);
-- 复合索引（提高查询性能）
CREATE INDEX idx_note_episode_type ON notes(episode_id, note_type);
CREATE INDEX idx_note_episode_highlight ON notes(episode_id, highlight_id);
```

---

#### 7. AIQueryRecord（AI 查询记录）- 作为缓存/日志！
| 字段 | 类型 | 说明 |
|------|------|------|
| id | Integer | 主键 |
| highlight_id | Integer | 外键 → Highlight（必需，CASCADE） |
| **查询内容** | | |
| query_text | Text | 用户查询的文本（划线内容，必需） |
| context_text | Text | 上下文（相邻 2-3 个 cue 的文本，可选） |
| response_text | Text | AI 返回的结果（JSON 字符串，可空，处理中或失败时为空）⭐ 优化 |
| **查询类型和提供商** | | |
| detected_type | String | AI 检测到的类型（word/phrase/sentence，从 response_text 解析得到，可为空）⭐ 优化 |
| provider | String | AI 提供商（默认从 config.DEFAULT_AI_PROVIDER）⭐ 优化 |
| **状态和错误信息** | | |
| status | String | processing/completed/failed（默认 processing）⭐ 优化 |
| error_message | Text | 错误信息（失败时记录，可空）⭐ 新增 |
| **时间戳** | | |
| created_at | DateTime | 创建时间 |

**设计要点**（Critical - AI 查询作为缓存/日志）⭐⭐⭐ **重要优化**：

- **字段优化说明**（⭐ 关键变更）：
  - `query_text`：`nullable=False`（必需，用户查询的内容）
  - `context_text`：`nullable=True`（可选，部分查询可能不需要上下文）
  - `response_text`：`nullable=True`（**存储 Gemini 返回的 JSON 字符串**，处理中或失败时为空）⭐
  - **`detected_type`**：`nullable=True`（**从 response_text 解析得到的 type 字段：word/phrase/sentence**，用于索引和查询）⭐
  - **删除 `query_type` 字段**：不再需要用户指定查询类型，AI 自动判断
  - `provider`：`nullable=False, default=config.DEFAULT_AI_PROVIDER`（从全局配置获取默认值）
  - `status`：`nullable=False, default="processing"`（默认处理中）
  - `error_message`：`nullable=True`（失败时记录错误原因）
  - 级联删除：删除 Highlight 时级联删除 AIQueryRecord（`ondelete="CASCADE"`）

- **AIQueryRecord 的定位**：
  - **缓存**：避免重复查询同样的内容（节省 Token 成本）
  - **日志**：记录所有 AI 查询历史，用于数据分析
  - **临时存储**：用户可能查询了但没有保存为笔记

- **独立存在，不强依赖 Note**：
  - 用户划线 → 点"AI 查询" → 立即创建 `AIQueryRecord`
  - 用户可能不保存为笔记（只是临时查看）
  - 如果保存为笔记，Note 通过 `origin_ai_query_id` 反向关联

- **查询缓存逻辑**（⭐ 优化：移除 query_type 依赖）：
  ```python
  # 用户划线查询前，先检查是否已有缓存（基于 highlight_id）
  existing = db.query(AIQueryRecord).filter(
      AIQueryRecord.highlight_id == highlight.id,
      AIQueryRecord.status == "completed"
  ).first()
  
  if existing:
      # 解析 JSON 并返回结构化数据
      response_json = json.loads(existing.response_text)
      return response_json  # 返回解析后的 JSON
  else:
      # 统一调用 AI API（不需要指定类型，AI 自动判断）
      response_json = ai_service.query(query_text, context_text)
      # 保存 JSON 字符串到 response_text，解析 type 到 detected_type
      ai_record = AIQueryRecord(
          highlight_id=highlight.id,
          query_text=query_text,
          context_text=context_text,
          response_text=json.dumps(response_json),  # 存储 JSON 字符串
          detected_type=response_json.get("type"),  # 解析并存储类型
          status="completed"
      )
      db.add(ai_record)
      db.commit()
  ```

- **`context_text` 的构建**：包含相邻 2-3 个 TranscriptCue 的文本，用于专有名词识别
- **`provider` 全局配置管理**（⭐ 优化）：
  - 默认值从 `config.DEFAULT_AI_PROVIDER` 获取（便于切换）
  - 支持灵活切换不同 AI 提供商（实验和对比）
  - 便于数据分析：统计不同模型的效果和成本

**反向关联**：
- `AIQueryRecord` → 可能被多个 `Note` 引用（`origin_ai_query_id`）
- 但删除 `AIQueryRecord` 不会删除 `Note`（Note 已经保存了 content）
- 删除 `Highlight` → 级联删除 `AIQueryRecord`（查询记录依赖于划线）

**索引优化**（⭐ 优化：移除 query_type 索引，新增 detected_type 索引）：
```sql
-- Highlight 级别的查询索引（高频：缓存查询）
CREATE INDEX idx_highlight_query ON ai_query_records(highlight_id);
-- 按状态查询（监控失败查询）
CREATE INDEX idx_query_status ON ai_query_records(status);
-- 按提供商查询（数据分析）
CREATE INDEX idx_query_provider ON ai_query_records(provider);
-- 按检测到的类型查询（数据分析）⭐ 新增
CREATE INDEX idx_query_detected_type ON ai_query_records(detected_type);
-- 复合索引（缓存查询优化）
CREATE INDEX idx_query_highlight_status ON ai_query_records(highlight_id, status);
CREATE INDEX idx_query_highlight_type ON ai_query_records(highlight_id, detected_type);  -- ⭐ 修改
```

---

### 级联删除规则（Critical）

**为什么需要级联删除**：
- PRD 326行："删除包括：笔记卡片、下划线效果、本地json数据"
- 保证数据一致性：删除父记录时自动清理所有关联的子记录
- 避免孤儿数据：防止数据库中出现无效的外键引用

**SQLAlchemy 实现**：

```python
# Episode 被删除 → 级联删除所有关联数据
class Episode(Base):
    segments = relationship("AudioSegment", back_populates="episode", cascade="all, delete-orphan")
    cues = relationship("TranscriptCue", back_populates="episode", cascade="all, delete-orphan")
    highlights = relationship("Highlight", back_populates="episode", cascade="all, delete-orphan")
    notes = relationship("Note", back_populates="episode", cascade="all, delete-orphan")

# Highlight 被删除 → 级联删除关联的 Note 和 AIQueryRecord
class Highlight(Base):
    # 简化设计：只关联一个 cue（⭐ 修改）
    cue = relationship("TranscriptCue", foreign_keys="Highlight.cue_id")
    
    # 分组管理（⭐ 新增）
    highlight_group_id = Column(String, nullable=True, index=True)
    
    # 级联删除
    notes = relationship("Note", back_populates="highlight", cascade="all, delete-orphan")
    ai_queries = relationship("AIQueryRecord", back_populates="highlight", cascade="all, delete-orphan")

# Note 不再级联删除 AIQueryRecord（反向关联）
class Note(Base):
    # Note 可能来自 AI 查询，但不拥有它
    origin_ai_query = relationship("AIQueryRecord", foreign_keys="Note.origin_ai_query_id")  # 不级联删除

# AIQueryRecord 独立存在，不依赖 Note
class AIQueryRecord(Base):
    highlight = relationship("Highlight", back_populates="ai_queries")
    # 反向：可能被多个 Note 引用，但不拥有它们

# Podcast 被删除 → Episode 不删除（设置为 NULL）
class Podcast(Base):
    episodes = relationship("Episode", back_populates="podcast")  # 不级联删除

class Episode(Base):
    podcast_id = Column(Integer, ForeignKey("podcasts.id", ondelete="SET NULL"), nullable=True)
```

**级联删除链**（更新）：

```
删除 Episode 
  → 自动删除 AudioSegment
  → 自动删除 TranscriptCue
  → 自动删除 Highlight
    → 自动删除 Note（Note.origin_ai_query_id 仍保留，但不影响）
    → 自动删除 AIQueryRecord

删除 Highlight
  → 自动删除 Note
  → 自动删除 AIQueryRecord

删除 Note
  → **不删除** AIQueryRecord（反向关联，Note 不拥有 AIQueryRecord）

删除 AIQueryRecord
  → **不删除** Note（Note 已经保存了 content，origin_ai_query_id 只是标记来源）

删除 Podcast
  → Episode 的 podcast_id 设置为 NULL（保留本地音频）
```

**关键变化**：
- `Note` 和 `AIQueryRecord` 的关系改为**反向关联**（Note 引用 AIQueryRecord，但不拥有它）
- 删除 `AIQueryRecord` 不会影响 `Note`（笔记已持久化）
- 删除 `Note` 不会影响 `AIQueryRecord`（查询记录作为缓存/日志保留）

**测试用例**（Task 1.1 必须包含）：

```python
def test_cascade_delete_episode(db):
    """测试删除 Episode 时级联删除所有关联数据"""
    episode = create_test_episode()
    segment = create_test_segment(episode.id)
    cue = create_test_cue(episode.id, segment.id)
    highlight = create_test_highlight(episode.id, cue.id, cue.id)  # 单句划线
    note = create_test_note(episode.id, highlight.id)
    ai_query = create_test_ai_query(highlight.id)
    
    # 删除 Episode
    db.delete(episode)
    db.commit()
    
    # 验证所有关联数据被删除
    assert db.query(AudioSegment).filter_by(episode_id=episode.id).count() == 0
    assert db.query(TranscriptCue).filter_by(episode_id=episode.id).count() == 0
    assert db.query(Highlight).filter_by(episode_id=episode.id).count() == 0
    assert db.query(Note).filter_by(episode_id=episode.id).count() == 0
    assert db.query(AIQueryRecord).filter_by(highlight_id=highlight.id).count() == 0


def test_single_cue_highlight(db):
    """测试单 cue 划线（90% 场景）⭐ 修改"""
    episode = create_test_episode()
    cue = create_test_cue(episode.id, text="Hello world.")
    
    # 创建单 cue 划线（划 "world"）
    highlight = Highlight(
        episode_id=episode.id,
        cue_id=cue.id,  # ⭐ 只关联一个 cue
        start_offset=6,
        end_offset=11,
        highlighted_text="world",
        highlight_group_id=None,  # 单 cue 不需要分组
        color="#9C27B0"
    )
    db.add(highlight)
    db.commit()
    
    # 验证关联
    assert highlight.cue_id == cue.id
    assert highlight.highlight_group_id is None


def test_cross_cue_highlight_with_grouping(db):
    """测试跨 cue 划线（自动拆分 + 分组管理）⭐ 新增"""
    episode = create_test_episode()
    cue1 = create_test_cue(episode.id, text="Hello world.")
    cue2 = create_test_cue(episode.id, text="This is a test.")
    cue3 = create_test_cue(episode.id, text="Thank you.")
    
    # 用户跨 cue 划线 → 自动拆分成 3 个 Highlight
    group_id = "uuid-12345"
    
    highlight1 = Highlight(
        episode_id=episode.id,
        cue_id=cue1.id,
        start_offset=6,
        end_offset=12,  # "world." 到末尾
        highlighted_text="world.",
        highlight_group_id=group_id,
        color="#9C27B0"
    )
    
    highlight2 = Highlight(
        episode_id=episode.id,
        cue_id=cue2.id,
        start_offset=0,
        end_offset=15,  # 完整 cue
        highlighted_text="This is a test.",
        highlight_group_id=group_id,
        color="#9C27B0"
    )
    
    highlight3 = Highlight(
        episode_id=episode.id,
        cue_id=cue3.id,
        start_offset=0,
        end_offset=5,  # "Thank"
        highlighted_text="Thank",
        highlight_group_id=group_id,
        color="#9C27B0"
    )
    
    db.add_all([highlight1, highlight2, highlight3])
    db.commit()
    
    # 验证分组
    highlights = db.query(Highlight).filter(
        Highlight.highlight_group_id == group_id
    ).all()
    assert len(highlights) == 3
    
    # 验证按组删除
    db.query(Highlight).filter(
        Highlight.highlight_group_id == group_id
    ).delete()
    db.commit()
    
    assert db.query(Highlight).count() == 0


def test_ai_query_to_note_conversion(db):
    """测试 AI 查询转笔记的逻辑（Critical ⭐ 优化：JSON 格式）"""
    import json
    
    episode = create_test_episode()
    cue = create_test_cue(episode.id, cue_index=1)
    highlight = create_test_highlight(episode.id, cue.id, cue.id)
    
    # 1. 用户划线 → AI 查询（Gemini 返回 JSON 格式）
    response_json = {
        "type": "word",
        "content": {
            "phonetic": "/tækˈsɒnəmi/",
            "definition": "分类学；分类法",
            "explanation": "生物学中用于分类和命名生物体的科学体系。"
        }
    }
    
    ai_query = AIQueryRecord(
        highlight_id=highlight.id,
        query_text="taxonomy",
        context_text="...",
        response_text=json.dumps(response_json),  # ⭐ 存储 JSON 字符串
        detected_type="word",  # ⭐ 从 JSON 解析得到的类型
        provider="gemini-2.5-flash",
        status="completed"
    )
    db.add(ai_query)
    db.commit()
    
    # 2. 用户点击"保存笔记" → 创建 Note
    # Note 的 content 格式化为可读文本（从 JSON 提取）
    note_content = f"{response_json['content']['definition']}\n{response_json['content']['explanation']}"
    
    note = Note(
        episode_id=episode.id,
        highlight_id=highlight.id,
        origin_ai_query_id=ai_query.id,  # 标记来源
        content=note_content,  # ⭐ 格式化的文本内容
        note_type="ai_card"
    )
    db.add(note)
    db.commit()
    
    # 验证关联
    assert note.origin_ai_query_id == ai_query.id
    assert note.note_type == "ai_card"
    assert ai_query.detected_type == "word"  # ⭐ 验证 detected_type
    
    # 3. 删除 AIQueryRecord → Note 保留
    db.delete(ai_query)
    db.commit()
    
    assert db.query(Note).filter_by(id=note.id).count() == 1  # Note 仍存在
    assert note.origin_ai_query_id == ai_query.id  # 外键保留（但记录已不存在）


def test_episode_show_name_property(db):
    """测试 Episode 的 show_name 属性（方案 1 优化）"""
    # 1. 创建关联 Podcast 的 Episode
    podcast = Podcast(title="Lenny's Podcast")
    db.add(podcast)
    db.commit()
    
    episode_with_podcast = Episode(
        title="Episode 1",
        podcast_id=podcast.id,
        file_hash="hash001"
    )
    db.add(episode_with_podcast)
    db.commit()
    
    # 验证 show_name 从 Podcast 获取
    assert episode_with_podcast.show_name == "Lenny's Podcast"
    assert episode_with_podcast.show_name == podcast.title
    
    # 2. 创建本地音频（无 Podcast）
    local_episode = Episode(
        title="Local Audio",
        podcast_id=None,
        file_hash="hash002"
    )
    db.add(local_episode)
    db.commit()
    
    # 验证 show_name 返回默认值
    assert local_episode.show_name == "本地音频"
    
    # 3. 使用 joinedload 优化查询（避免 N+1 问题）
    from sqlalchemy.orm import joinedload
    
    episodes = db.query(Episode).options(joinedload(Episode.podcast)).all()
    
    # 访问 show_name 不会触发额外查询
    for ep in episodes:
        _ = ep.show_name  # 高效访问
    
    assert len(episodes) == 2
```

---

### 存储优化策略总结

| 方案 | 存储占用 | 实现复杂度 | 采用 |
|------|---------|-----------|-----|
| 物理分段（切割文件） | 200% | 简单 | ❌ |
| **虚拟分段（临时文件）** | **100%** | **简单** | **✅** |
| 符号链接 | 100% | 复杂 | ❌ |

**虚拟分段工作流程**（优化版 - 支持中断恢复）：
1. 用户上传音频 → 保存到 `backend/data/audios/{file_hash}.mp3`
2. 创建虚拟分段 → `AudioSegment` 表记录时间范围，`segment_path = NULL`，`status = "pending"`
3. 转录开始 → FFmpeg 提取片段到持久临时文件（`backend/data/temp_segments/segment_001_abc123.wav`）
4. 记录临时文件路径 → 更新 `segment_path`，`status = "processing"`
5. 调用 Whisper 转录临时文件
6. **转录成功** → 删除临时文件，清空 `segment_path = NULL`，`status = "completed"`
7. **转录失败** → 保留临时文件和路径（`segment_path` 不变），`status = "failed"`，重试时直接使用
8. **定期清理** → 后台任务清理超过 30 分钟的失败转录临时文件

**关键代码**（优化版 - 支持中断恢复和重试）：
```python
import os

# 1. 检查是否已有临时文件（重试场景）
if segment.segment_path and os.path.exists(segment.segment_path):
    temp_path = segment.segment_path
else:
    # 2. 创建持久临时文件路径
    temp_dir = "backend/data/temp_segments/"
    os.makedirs(temp_dir, exist_ok=True)
    temp_path = f"{temp_dir}segment_{segment.segment_index:03d}_{episode.file_hash}.wav"
    
    # 3. 用 FFmpeg 提取片段并转码为 WAV
    subprocess.run([
        "ffmpeg", "-y",
        "-i", episode.audio_path,
        "-ss", str(segment.start_time),
        "-t", str(segment.duration),
        # 不使用 -c copy！MP3 只能在关键帧切割，会导致时间戳偏移
        "-ar", "16000",      # Whisper 需要 16kHz 采样率
        "-ac", "1",          # 单声道
        "-c:a", "pcm_s16le", # PCM 编码，精准切割（秒级精度）
        temp_path
    ], check=True)
    
    # 4. 记录临时文件路径
    segment.segment_path = temp_path
    segment.status = "processing"
    db.commit()

try:
    # 5. 转录临时文件
    cues = whisper_service.transcribe(temp_path)
    
    # 6. 转录成功，删除临时文件
    os.remove(temp_path)
    segment.segment_path = None
    segment.status = "completed"
    
except Exception as e:
    # 7. 转录失败，保留临时文件和路径（用于重试）
    segment.status = "failed"
    segment.error_message = str(e)
    segment.retry_count += 1
    # segment.segment_path 保留，重试时可直接使用

db.commit()
```

**关键修正说明**：
- ❌ **禁止使用 `-c copy`**：MP3 压缩格式只能在关键帧处切割，时间戳不精确
- ✅ **转码为 WAV（PCM）**：秒级精准切割，且 Whisper 内部也需要转为 16kHz Mono
- ✅ **性能影响可控**：3 分钟片段转码 < 2 秒（完全可接受）

---

## 二、开发策略

### 核心原则：后端优先 + TDD + 前后端并行迭代

#### 为什么后端优先？
1. **数据和逻辑核心**：Whisper 转录、数据库 CRUD、AI 查询都在后端
2. **前端依赖后端 API**：前端组件需要真实数据才能验证交互逻辑
3. **TDD 更容易实施**：后端测试比前端 UI 测试更易编写和验证

#### 开发阶段划分
- **阶段一（后端为主）**：搭建后端核心功能 API + 单元测试
- **阶段二（前后端并行）**：前端消费 API，后端根据前端反馈调整接口
- **阶段三（前端为主）**：UI 交互优化、状态管理、响应式布局

---

## 三、原子任务拆分

### 阶段 1：后端数据层 + Whisper 转录（Week 1）

#### Task 1.1：数据库模型重构
**优先级**: P0（最高）  
**预计工时**: 6 小时（增加了表数量和复杂度）

- [ ] **测试先行**：编写 `backend/tests/test_models_new.py`
  - 测试所有 7 个表创建成功
  - 测试外键关联：
    - Episode → Podcast（可选，ondelete="SET NULL"）
    - AudioSegment → Episode（cascade）
    - TranscriptCue → Episode & AudioSegment（cascade）
    - **Highlight → Episode & TranscriptCue（单 cue 关联：cue_id）⭐ 简化设计**
    - Note → Episode & Highlight & AIQueryRecord（origin_ai_query_id）
    - AIQueryRecord → Highlight（cascade）
  
  - 测试数据插入和查询
  
  - **测试级联删除**（Critical，对应 PRD 326行）：
    - 删除 Episode → 验证 AudioSegment、TranscriptCue、Highlight、Note、AIQueryRecord 全部被删除
    - 删除 Highlight → 验证 Note 和 AIQueryRecord 被删除
    - **删除 Note → AIQueryRecord 保留**（反向关联）
    - **删除 AIQueryRecord → Note 保留**（Note 已持久化）
    - 删除 Podcast → 验证 Episode 保留（podcast_id 设为 NULL）
  
  - **测试 Highlight 划线**（Critical，简化设计 ⭐）：
    - 单 cue 划线：`cue_id` 关联单个 cue，`highlight_group_id = None`（90% 场景）
    - 跨 cue 划线：多个 Highlight 共享 `highlight_group_id`（10% 场景）
    - 验证按组删除逻辑：删除一个，同组全删
    - 验证 Highlight 使用 `cue.id`（主键）关联，不使用 cue_index
    - **测试新字段**（⭐ 优化）：
      - `color` 字段有数据库默认值 `#9C27B0`
      - `updated_at` 字段自动更新（修改 color 时）
      - `highlight_group_id` 可为 NULL（单 cue 划线时）
    - **测试级联删除**：
      - 删除 Episode → 所有 Highlight 被删除
      - 删除 TranscriptCue → 关联的 Highlight 被删除
  
  - **测试 AI 查询到笔记的转化**（Critical ⭐ 优化）：
    - 创建 AIQueryRecord（`response_text` 存储 JSON 字符串，`detected_type` 从 JSON 解析得到）
    - 保存为 Note → 验证 `origin_ai_query_id` 关联
    - 删除 AIQueryRecord → 验证 Note 保留
    - 验证 `note_type = 'ai_card'`
    - 验证 `detected_type` 字段正确存储（word/phrase/sentence）
  
  - 测试唯一索引：`Episode.file_hash` 唯一性
  - 测试虚拟分段：创建 AudioSegment 时 `segment_path = NULL`
  
  - **测试 AudioSegment 新字段**（⭐ 新增）：
    - AudioSegment 包含 `retry_count` 字段（默认 0）
    - AudioSegment 包含 `transcription_started_at` 字段（用于排序和监控）
    - AudioSegment 不包含 `cue_count` 字段（已删除，冗余）
    - AudioSegment 的 `segment_index` 必须连续（0, 1, 2, 3...），用于保证顺序
    - 测试重试机制：segment 失败后，`retry_count` 正确递增
  
  - **测试新字段**：
    - **TranscriptCue 字段**（⭐ 最终方案）：
      - **不包含** `cue_index` 字段（已移除，避免维护成本）
      - 查询时使用 `ORDER BY start_time` 确保顺序
      - 验证异步转录场景下，无需重新索引，Highlight 关联依然稳定
    - **Highlight 字段**（⭐ 简化）：
      - 包含 `cue_id` 字段（主键关联）
      - 包含 `highlight_group_id` 字段（UUID）
      - 默认颜色为紫色（#9C27B0）
    - **Note 字段**：
      - 包含 `origin_ai_query_id` 字段
      - `note_type` 支持 'underline', 'thought', 'ai_card'
      - 不包含 `position_top` 和 `user_avatar` 字段
    - **AIQueryRecord 字段**（⭐ 优化）：
      - **不包含 `query_type` 字段**（已删除，AI 自动判断类型）
      - **包含 `detected_type` 字段**（nullable=True，从 response_text 解析得到的 type：word/phrase/sentence）
      - 包含 `provider` 字段
      - `response_text` 存储 JSON 字符串（Gemini 返回的完整 JSON）
    - **Episode 表优化**：
      - 不包含 `show_name` 字段（使用 @property 动态获取）
      - **包含 `transcription_status` 物理字段**（用于高效查询：pending/processing/completed/failed）
      - 不包含 `needs_segmentation/segment_duration/total_segments` 字段（全局配置 + @property）
      - 不包含 `transcription_started_at/transcription_completed_at` 物理字段（使用 @property 从 Segment 聚合）
    - **Episode 用户层属性**：
      - `transcription_progress` 返回百分比（0-100）
      - `transcription_status_display` 返回友好文本
      - `estimated_time_remaining` 返回预计剩余秒数
    - **Episode 调试层属性**：
      - `transcription_stats` 返回完整段数统计
      - `failed_segments_detail` 返回失败段详情

- [ ] **实现配置文件**：创建 `backend/app/config.py`
  - 定义全局配置参数：
    ```python
    # 音频分段配置（系统级参数，需要实验找到最优值）
    SEGMENT_DURATION = 180  # 默认 180 秒（3 分钟）
    
    # 说明：
    # - 影响转录速度和内存占用
    # - 太小：分段过多，转录慢
    # - 太大：单段转录时间长，用户等待久
    # - 建议范围：120-300 秒
    ```

- [ ] **实现模型**：重构 `backend/app/models.py`
  - 添加 7 个新表模型：
    1. `Podcast`（播客）
    2. `Episode`（单集，含 file_hash 等）
       - **不包含 show_name 字段**（消除数据冗余）
       - **实现 @property show_name**：动态获取节目名称
       - **不包含 needs_segmentation/segment_duration/total_segments 字段**（全局配置优化）
       - **实现分段相关 @property**（基于全局配置动态计算）：
         
         ```python
         @property
         def segment_duration(self):
             """返回全局配置的分段时长"""
             from app.config import SEGMENT_DURATION
             return SEGMENT_DURATION
         
         @property
         def needs_segmentation(self):
             """是否需要分段（基于全局配置）"""
             return self.duration > self.segment_duration
         
         @property
         def total_segments(self):
             """总段数（动态计算）"""
             if not self.needs_segmentation:
                 return 1
             import math
             return math.ceil(self.duration / self.segment_duration)
         ```
       - **删除转录状态字段**（双层设计优化）
       - **实现转录状态 @property**（用户层 + 调试层）：
         
         ```python
         # ========== 用户界面层（简洁） ==========
         @property
         def transcription_progress(self):
             """返回百分比 0-100（用于进度条）"""
             if not self.segments:
                 return 0.0
             completed = sum(1 for s in self.segments if s.status == "completed")
             return round((completed / len(self.segments)) * 100, 2)
         
         @property
         def transcription_status_display(self):
             """返回友好的状态文本（隐藏技术细节）"""
             status_map = {
                 "pending": "等待转录",
                 "processing": "正在转录中...",
                 "completed": "转录完成",
                 "partial_failed": "部分转录失败，可继续使用",
                 "failed": "转录失败，请重试"
             }
             return status_map.get(self.transcription_status, "未知状态")
         
         @property
         def estimated_time_remaining(self):
             """返回预计剩余秒数（用户关心的信息）"""
             pending = sum(1 for s in self.segments if s.status in ["pending", "processing"])
             return int(pending * 180 * 0.4)  # 每段180s，转录速度0.4x
         
         # ========== 开发调试层（详细） ==========
         @property
         def transcription_stats(self):
             """返回完整的段数统计（仅供调试）"""
             if not self.segments:
                 return {"total_segments": 0, "completed_segments": 0, ...}
             return {
                 "total_segments": len(self.segments),
                 "completed_segments": sum(1 for s in self.segments if s.status == "completed"),
                 "failed_segments": sum(1 for s in self.segments if s.status == "failed"),
                 ...
             }
         
         @property
         def failed_segments_detail(self):
             """返回失败段的详细信息（仅供调试）"""
             return [
                 {"segment_id": s.segment_id, "error_message": s.error_message, ...}
                 for s in self.segments if s.status == "failed"
             ]
         ```
    3. `AudioSegment`（虚拟分段，segment_path 可为空）
    4. **`TranscriptCue`**（字幕片段，含 speaker，cue_index 可选 ⭐ 简化）
    5. **`Highlight`**（用户划线，单 cue 关联 + 分组管理 ⭐ 简化）
       - 只包含 `cue_id`（不包含 start_cue_id/end_cue_id）
       - 包含 `highlight_group_id`（UUID，用于跨 cue 划线分组）
    6. **`Note`**（笔记：underline/thought/ai_card，含 origin_ai_query_id）
    7. **`AIQueryRecord`**（AI 查询记录，含 provider 和 detected_type，独立于 Note）⭐ 优化
    8. `Vocabulary`（生词本）
  
  - 添加 SQLAlchemy `relationship` 关系映射：
    - **Highlight 的单外键关系**（⭐ 简化）：`cue`（关联单个 TranscriptCue）
    - **分组管理**：`highlight_group_id` 索引（用于按组查询和删除）
    - **Note 的反向关联**：`origin_ai_query`（不拥有 AIQueryRecord）
    - **AIQueryRecord 独立存在**：不被 Note 拥有
  
  - **配置级联删除规则**（Critical）：
    - Episode: `cascade="all, delete-orphan"`
    - Highlight: `cascade="all, delete-orphan"`
    - AIQueryRecord: 由 Highlight 级联删除
    - **Note 不级联删除 AIQueryRecord**（反向关联）
    - Podcast → Episode: `ondelete="SET NULL"`
  
  - 配置外键约束和索引（见数据库设计部分）
  
  - 添加默认值：
    - `TranscriptCue.speaker = "Unknown"`
    - `Highlight.color = "#9C27B0"`（紫色）
    - `AudioSegment.segment_path = None`（虚拟分段）
    - `AIQueryRecord.status = "processing"`
    - `AIQueryRecord.provider = config.DEFAULT_AI_PROVIDER` ⭐ 新增

  - [ ] **数据库迁移**
  - 删除旧的 `data/podflow.db`（如果存在）
  - 运行 `init_db()` 创建新表
  - 验证表结构（使用 SQLite 客户端查看）
  - 验证索引创建成功

- [ ] **验收标准**
  - [ ] 所有测试用例通过（绿色）
  - [ ] 数据库文件成功创建，包含 7 个表
  - [ ] 可以手动插入测试数据
  - [ ] `Episode.file_hash` 唯一索引生效
  - [ ] 虚拟分段测试通过（segment_path 为 NULL）
  - [ ] **级联删除测试全部通过**（删除父记录时子记录被自动清理）
  - [ ] **Highlight 划线测试通过**（Critical ⭐ 简化）：
    - 单 cue 划线正确创建（90% 场景）
    - 跨 cue 划线自动拆分 + 分组管理（10% 场景）
    - 按组删除正确工作（删除一个，同组全删）
    - Highlight 使用 `cue.id`（主键）关联，不依赖 cue_index
  - [ ] **AI 查询转笔记测试通过**（Critical）：
    - AIQueryRecord 可以转换为 Note
    - 删除 AIQueryRecord 不影响 Note
    - 删除 Note 不影响 AIQueryRecord
  - [ ] 新字段验证通过：
    - **TranscriptCue 字段**（⭐ 最终方案）：
      - **不包含** `cue_index` 字段（已移除，避免维护成本）
      - 查询时使用 `ORDER BY start_time` 确保顺序
      - 验证异步转录场景下，无需重新索引，Highlight 关联依然稳定
    - **Highlight 字段**（⭐ 简化）：
      - 包含 `cue_id` 字段（主键关联）
      - 包含 `highlight_group_id` 字段（UUID）
      - 默认颜色为紫色（#9C27B0）
    - **Note 字段**：
      - 包含 `origin_ai_query_id` 字段
      - `note_type` 支持 'underline', 'thought', 'ai_card'
      - 不包含 `position_top` 和 `user_avatar` 字段
    - **AIQueryRecord 字段**（⭐ 优化）：
      - **不包含 `query_type` 字段**（已删除，AI 自动判断类型）
      - **包含 `detected_type` 字段**（nullable=True，从 response_text 解析得到）
      - 包含 `provider` 字段
      - `response_text` 存储 JSON 字符串
  - [ ] **Episode 表优化验证通过**（多项优化）：
    - **节目名称优化**：
      - Episode 表不包含 show_name 字段
      - Episode.show_name @property 能正确返回 Podcast.title
      - 本地音频（podcast_id=None）的 show_name 返回 "本地音频"
    - **分段信息优化**：
      - Episode 表不包含 needs_segmentation/segment_duration/total_segments 字段
      - Episode.segment_duration 返回全局配置值（180）
      - Episode.needs_segmentation 能正确判断（duration > 180）
      - Episode.total_segments 能正确计算（ceil(duration / 180)）
      - 修改全局配置后，属性值自动更新
    - **转录状态优化**：
      - **包含 `transcription_status` 物理字段**（用于高效查询：pending/processing/completed/failed）
      - 不包含 `transcription_progress/transcription_status_display/estimated_time_remaining` 物理字段（使用 @property 动态计算）
      - 不包含 `transcription_started_at/transcription_completed_at` 物理字段（使用 @property 从 Segment 聚合）
    - **用户层属性验证**：
      - transcription_progress 返回正确的百分比
      - transcription_status_display 返回友好文本（无技术术语）
      - estimated_time_remaining 计算准确（基于剩余段数）
    - **调试层属性验证**：
      - transcription_stats 返回完整的段数统计
      - failed_segments_detail 返回失败段的详细信息
    - **关注点分离验证**：
      - 用户界面不显示段数信息（隐藏技术细节）
      - 调试界面显示完整数据（便于问题排查）
    - 使用 joinedload 查询时无 N+1 问题
  - [ ] 所有复合索引创建成功

---

#### Task 1.2：Whisper 转录服务实现（虚拟分段 + 临时文件）
**优先级**: P0  
**预计工时**: 10 小时（新增虚拟分段逻辑）

- [x] **测试先行**：编写 `backend/tests/test_whisper_service.py` ✅
  - ✅ 测试单例模式（get_instance_before_load_raises_error, get_instance_after_load_returns_same_instance）
  - ✅ 测试模型加载（CPU/CUDA 模式、模型目录创建、错误处理）
  - ✅ 测试完整转录流程（带/不带说话人区分）
  - ✅ 测试 FFmpeg 片段提取（成功/失败场景、文件不存在、FFmpeg 未安装）
  - ✅ 测试设备信息获取
  - ✅ 测试结果格式化（空文本过滤、默认 speaker）
  - ✅ 测试异常处理（文件不存在、模型未加载）

- [x] **实现 Whisper 服务**：创建 `backend/app/services/whisper_service.py` ✅
  - ✅ 实现单例模式（`get_instance()` 类方法）
  - ✅ 实现 `load_models()` 类方法（应用启动时加载 ASR 模型到显存）
  - ✅ 实现 `transcribe_segment()` 方法（分段转录）
    - 返回标准格式 cue 列表（包含 start, end, speaker, text）
    - 完整流程：转录 + 对齐 + 说话人区分（可选）
    - 使用 WhisperX 完整流程
    - 支持 Diarization 模型复用（避免分段间重复加载）
  - ✅ 实现 Diarization 模型生命周期管理
    - `load_diarization_model()`：显式加载模型（Episode 处理开始前）
    - `release_diarization_model()`：显式释放模型（Episode 处理结束后）
    - 支持显存清理（`gc.collect()` + `torch.cuda.empty_cache()`）
  - ✅ 实现 `extract_segment_to_temp()` 方法
    - 使用 FFmpeg 提取片段到临时文件（WAV 格式）
    - **使用 PCM 编码（pcm_s16le）**，确保秒级精准切割（Critical ⚠️）
    - 输出 16kHz 单声道 WAV 文件
    - 支持自定义输出目录
  - ✅ 添加设备自动检测（CUDA/CPU）
  - ✅ 添加完整的日志记录（使用 Python `logging`）
  - ✅ 集成硬件兼容性补丁（在导入 whisperx 前自动应用）
  - ✅ 设备信息增强（`get_device_info()` 新增 `diarization_model_loaded` 和 `vram_allocated`）

- [ ] **实现虚拟分段转录逻辑**：创建 `backend/app/services/transcription_service.py`
  - 实现 `segment_and_transcribe(episode_id: int)`：
    ```python
    # Step 1: 创建虚拟分段
    num_segments = math.ceil(episode.duration / 180)
    for i in range(num_segments):
        AudioSegment(
            episode_id=episode.id,
            segment_index=i,
            segment_id=f"segment_{i+1:03d}",
            segment_path=None,  # 虚拟分段
            start_time=i * 180,
            end_time=min((i + 1) * 180, episode.duration),
            status="pending"
            # duration 通过 @property 动态计算，无需存储
        )
    
    # Step 2: 按顺序转录每个虚拟分段
    for segment in episode.segments:
        await transcribe_virtual_segment(segment)
    ```
  - 实现 `transcribe_virtual_segment(segment: AudioSegment)`（优化版 - 支持中断恢复）：
    ```python
    import os
    
    # 检查是否已有临时文件（重试场景）
    if segment.segment_path and os.path.exists(segment.segment_path):
        temp_path = segment.segment_path
    else:
        # 创建持久临时文件
        temp_dir = "backend/data/temp_segments/"
        os.makedirs(temp_dir, exist_ok=True)
        temp_path = f"{temp_dir}segment_{segment.segment_index:03d}_{episode.file_hash}.wav"
        
        # 提取片段到临时文件（WAV 格式，精准切割）
        subprocess.run([
            "ffmpeg", "-y",
            "-i", episode.audio_path,
            "-ss", str(segment.start_time),
            "-t", str(segment.duration),
            "-ar", "16000",      # Whisper 需要 16kHz
            "-ac", "1",          # 单声道
            "-c:a", "pcm_s16le", # PCM 编码，精准切割
            temp_path
        ], check=True)
    
    # 记录临时文件路径，更新状态
    segment.segment_path = temp_path
    segment.status = "processing"
    segment.transcription_started_at = datetime.utcnow()
    db.commit()
    
    try:
        # 转录临时文件
        cues = whisper_service.transcribe(temp_path)
        
        # 保存 TranscriptCue 到数据库（分配 cue_index）
        save_cues_to_db(cues, segment, db)
        
        # 转录成功，删除临时文件
        os.remove(temp_path)
        segment.segment_path = None
        segment.status = "completed"
        segment.recognized_at = datetime.utcnow()
        db.commit()
        
    except Exception as e:
        # 转录失败，保留临时文件和路径（用于重试）
        segment.status = "failed"
        segment.error_message = str(e)
        segment.retry_count += 1
        db.commit()
        raise
    ```
  
  - 实现 `save_cues_to_db(cues: List[Dict], segment: AudioSegment, db: Session)`（⭐ 最终方案：无索引）：
    ```python
    """
    保存字幕到数据库
    
    关键逻辑：
    1. 直接保存 cue，不存储 cue_index
    2. 使用 start_time = segment.start_time + cue['start'] 计算绝对时间
    3. Highlight 使用 cue.id 关联，天然支持异步/并发写入
    """
    def save_cues_to_db(cues: List[Dict], segment: AudioSegment, db: Session):
        new_cues = []
        for cue_data in cues:
            cue = TranscriptCue(
                episode_id=segment.episode_id,
                segment_id=segment.id,
                # 计算绝对时间
                start_time=cue_data["start"] + segment.start_time,
                end_time=cue_data["end"] + segment.start_time,
                speaker=cue_data.get("speaker", "Unknown"),
                text=cue_data["text"]
                # 移除 cue_index
            )
            new_cues.append(cue)
        
        db.add_all(new_cues)
        db.commit()
        return len(new_cues)
    ```
  
- [ ] **异步任务队列**
  - 使用 FastAPI `BackgroundTasks` 处理转录
  - 转录期间更新 `Episode.transcription_status` 为 `processing`
  - 更新 `Episode.transcription_progress`（百分比）
  - 转录完成后更新为 `completed`，失败则更新为 `failed`
  - 支持暂停/恢复识别（记录当前 segment）

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 转录一个 5 分钟音频 < 2 分钟
  - [ ] 转录过程中 API 不阻塞
  - [ ] 生成的 TranscriptCue 包含准确的时间戳和 speaker
  - [ ] **时间戳精度测试**（Critical ⚠️）：
    - 手动在音频中找一个明确的声音（如 "hello"）
    - 验证 Whisper 返回的 `start_time` 与实际音频时间偏差 < 0.5 秒
    - 验证跨段字幕时间连续性（segment_001 最后一句和 segment_002 第一句无重叠）
  - [ ] **字幕排序测试**（Critical）：
    - 验证 API 返回的字幕列表按 `start_time` 升序排列
    - 验证异步转录（乱序完成）后，通过 `start_time` 排序依然能获得正确的全文顺序
  - [ ] **Highlight 关联稳定性测试**：
    - 验证 Highlight 使用 `cue.id`（主键）关联
    - 验证无论 Segment 何时完成，Highlight 与字幕的对应关系永不漂移
  - [ ] **重试机制测试**：
    - 模拟 segment 失败后重试成功
    - 验证：`retry_count` 正确递增
    - 验证：重试成功后，字幕按 start_time 排序依然正确
  - [ ] 临时文件在转录完成后自动删除
  - [ ] 存储占用验证：只有一份完整音频（无分段文件）
  - [ ] FFmpeg 提取性能测试：3 分钟片段转码 < 2 秒（PCM 编码）

---

#### Task 1.3：Episode 管理 API（含文件去重）
**优先级**: P0  
**预计工时**: 8 小时（新增文件去重和 MD5 计算）

- [ ] **测试先行**：编写 `backend/tests/test_episode_api.py`
  - 测试上传音频文件（`multipart/form-data`）
  - 测试文件去重：
    - 上传相同文件两次 → 返回已存在的 Episode
    - 验证 `file_hash` 唯一性
  - **测试异步 MD5 计算**（Critical ⚠️）：
    - 模拟同时上传多个文件（并发请求）
    - 验证计算 MD5 期间，其他 API 请求（如 `GET /episodes`）仍能正常响应
    - 验证响应时间：其他请求延迟 < 100ms（不被 MD5 计算阻塞）
  - 测试创建 Episode（验证数据库记录）
  - 测试触发 Whisper 转录（验证状态变更）
  - 测试查询 Episode 列表（分页）
  - 测试查询单个 Episode 详情（包含 TranscriptCue）
  - 测试获取转录进度（轮询接口）

- [ ] **实现 API**：在 `backend/app/api.py` 添加路由

  **POST /api/episodes/upload**
  ```python
  # 功能：上传音频文件，创建 Episode，触发异步转录
  # 请求：multipart/form-data (audio_file, title, podcast_id)
  # 响应：{ "episode_id": 1, "status": "processing", "is_duplicate": false }
  
  # 实现逻辑：
  # 1. 计算 MD5 hash（边读边算，节省内存）
  # 2. 检查数据库是否已存在（file_hash）
  # 3. 如果已存在：返回已有的 Episode
  # 4. 如果不存在：
  #    - 保存到 backend/data/audios/{file_hash}.mp3
  #    - 创建 Episode 记录
  #    - 触发异步转录
  ```

  **GET /api/episodes**
  ```python
  # 功能：获取 Episode 列表（支持分页）
  # 参数：?page=1&limit=20&podcast_id=1&status=completed
  # 响应：{ "items": [...], "total": 50, "page": 1, "pages": 3 }
  ```

  **GET /api/episodes/{id}**
  ```python
  # 功能：获取单集详情（包含所有 TranscriptCue）
  # 响应：{
  #   "id": 1,
  #   "title": "...",
  #   "duration": 1800,
  #   "transcription_status": "completed",
  #   "cues": [
  #     { "id": 0, "start": 0.28, "end": 2.22, "speaker": "Lenny", "text": "..." }
  #   ]
  # }
  ```

  **GET /api/episodes/{id}/status**
  ```python
  # 功能：查询转录状态（用于前端轮询）
  # 响应：{
  #   "status": "processing",
  #   "progress": 45.5,
  #   "completed_segments": 5,
  #   "total_segments": 11
  # }
  ```

  **GET /api/episodes/{id}/segments**
  ```python
  # 功能：获取虚拟分段信息（用于调试）
  # 响应：[
  #   { "segment_id": "segment_001", "status": "completed", "cue_count": 15 },
  #   { "segment_id": "segment_002", "status": "processing", "cue_count": 0 }
  # ]
  ```

- [ ] **文件存储逻辑**
  - 实现 `calculate_md5(file: UploadFile) -> str`
    - 边读边算（chunk by chunk），节省内存
    - 使用 `hashlib.md5()`
    - **必须使用 ThreadPoolExecutor 异步执行**（Critical ⚠️）：
      ```python
      import asyncio
      from concurrent.futures import ThreadPoolExecutor
      
      executor = ThreadPoolExecutor()
      
      def calculate_md5_sync(file_path: str) -> str:
          """同步版本的 MD5 计算（在线程池中执行）"""
          hash_md5 = hashlib.md5()
          with open(file_path, "rb") as f:
              for chunk in iter(lambda: f.read(1024 * 1024), b""):  # 1MB chunks
                  hash_md5.update(chunk)
          return hash_md5.hexdigest()
      
      @app.post("/upload")
      async def upload_file(file: UploadFile):
          # Step 1: 先保存到临时文件
          temp_path = f"/tmp/{file.filename}"
          with open(temp_path, "wb") as f:
              shutil.copyfileobj(file.file, f)
          
          # Step 2: 异步计算 MD5（不阻塞其他请求）
          loop = asyncio.get_event_loop()
          file_hash = await loop.run_in_executor(executor, calculate_md5_sync, temp_path)
          
          # Step 3: 移动到最终路径
          final_path = f"backend/data/audios/{file_hash}.mp3"
          shutil.move(temp_path, final_path)
          # ...
      ```
    - **为什么必须用线程池**：
      - Python GIL 限制：即使分块读取，计算密集型任务仍会阻塞主线程
      - 影响：上传大文件时（如 500MB），计算 MD5 需要 20-30 秒，期间其他用户的 API 请求（如获取字幕）会被卡住
      - 解决：`run_in_executor` 将计算扔到线程池，释放主线程
  
  - 音频文件保存到 `backend/data/audios/{file_hash}.mp3`
  - 验证文件大小（< 1GB）
  - 验证文件格式（MP3, WAV）
  - 获取音频时长（使用 `pydub` 或 `ffprobe`）

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] Swagger 文档自动生成（访问 `/docs`）
  - [ ] 可以通过 Postman 测试上传音频
  - [ ] 文件去重测试通过：相同文件只存储一次
  - [ ] **异步 MD5 测试通过**（Critical ⚠️）：
    - 上传 100MB 文件期间，其他 API 请求（如 `GET /episodes`）响应延迟 < 100ms
    - 并发上传 3 个文件，所有文件都能正常计算 MD5（无死锁）
  - [ ] MD5 计算性能测试：100MB 文件 < 5 秒
  - [ ] 转录进度轮询正常工作

---

### 阶段 2：前端播放器 + 字幕展示（Week 2）

#### Task 2.1：音频播放器组件
**优先级**: P0  
**预计工时**: 6 小时

- [ ] **测试先行**：编写 `frontend/src/components/__tests__/AudioPlayer.test.jsx`
  - 测试组件渲染
  - 测试播放/暂停切换
  - 测试进度条拖动（更新 `currentTime`）
  - 测试音量控制
  - 测试 Hover 状态（按钮背景色变化）
  - 测试 Active 状态（按钮按下效果）

- [ ] **实现组件**：创建 `frontend/src/components/AudioPlayer.jsx`
  - 使用 HTML5 `<audio>` + MUI `Box`/`IconButton` 组件
  - 状态管理：
    - `currentTime`：当前播放时间（秒）
    - `duration`：音频总时长（秒）
    - `isPlaying`：播放状态（布尔值）
    - `volume`：音量（0-1）
  - 实现控制功能：
    - 播放/暂停按钮（PlayArrow / Pause 图标）
    - 进度条（MUI `Slider` 组件）
    - 时间显示（`00:00 / 05:30` 格式）
    - 音量按钮（VolumeUp / VolumeMute 图标）

- [ ] **交互状态验证**（三状态原则）
  - Normal：默认蓝色按钮
  - Hover：背景色加深（`sx={{ '&:hover': { bgcolor: 'primary.dark' } }}`）
  - Active：点击时涟漪效果 + 轻微缩放（`sx={{ '&:active': { transform: 'scale(0.95)' } }}`）

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 可以播放测试音频
  - [ ] 拖动进度条实时更新播放位置
  - [ ] 按钮交互流畅（无延迟）

---

#### Task 2.2：提取音频播放 Hooks（重构第一步）
**优先级**: P0  
**预计工时**: 3 小时

- [ ] **测试先行**：编写 `frontend/src/hooks/__tests__/useAudio.test.js`
  - 测试播放/暂停切换
  - 测试进度控制（seek, skip）
  - 测试音量控制（volume, mute）
  - 测试倍速控制（playbackRate）
  - 测试时间更新（currentTime, duration）

- [ ] **实现 Hook**：创建 `frontend/src/hooks/useAudio.js`
  - 从 `AudioPlayer.jsx` 提取音频播放逻辑
  - 返回：`{ currentTime, duration, isPlaying, play, pause, togglePlay, seek, skip, volume, setVolume, isMuted, toggleMute, playbackRate, setPlaybackRate }`
  - 使用 `useRef` 管理 `<audio>` 元素
  - 使用 `useState` 管理播放状态

- [ ] **测试先行**：编写 `frontend/src/hooks/__tests__/useIdle.test.js`
  - 测试鼠标活动检测
  - 测试 5s 无操作后返回 `isIdle = true`
  - 测试鼠标移动后返回 `isIdle = false`

- [ ] **实现 Hook**：创建 `frontend/src/hooks/useIdle.js`
  - 从 `AudioPlayer.jsx` 提取 5s 无操作检测逻辑
  - 监听鼠标活动，返回 `isIdle` 状态
  - 使用 `useEffect` + `setTimeout` 实现

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] `useAudio` Hook 可独立使用
  - [ ] `useIdle` Hook 可独立使用
  - [ ] 不影响现有 `AudioPlayer` 功能

---

#### Task 2.3：拆分音频播放器组件（重构第二步）
**优先级**: P0  
**预计工时**: 6 小时

- [ ] **测试先行**：编写 `frontend/src/components/player/__tests__/ProgressBar.test.jsx`
  - 测试进度条渲染（显示当前进度百分比）
  - 测试拖拽交互（鼠标按下、拖拽、松开）
  - 测试点击跳转（点击进度条任意位置）
  - 测试 Hover 显示时间（鼠标悬停显示时间提示）
  - 测试三状态（Normal/Hover/Active）

- [ ] **实现组件**：创建 `frontend/src/components/player/ProgressBar.jsx`
  - 提取进度条相关代码（从 `AudioPlayer.jsx`）
  - Props: `currentTime`, `duration`, `onChange`, `onChangeCommitted`, `onClick`
  - 使用 MUI `Slider` 组件
  - 实现完整的拖拽交互逻辑（鼠标事件处理）
  - 实现 Hover 显示时间提示（Tooltip）

- [ ] **测试先行**：编写 `frontend/src/components/player/__tests__/MiniAudioBar.test.jsx`
  - 测试收缩态 UI 渲染（5px 进度条线）
  - 测试点击展开（点击后调用 `onClick` 回调）
  - 测试进度显示（进度条着色百分比正确）

- [ ] **实现组件**：创建 `frontend/src/components/player/MiniAudioBar.jsx`
  - 提取收缩态 UI（从 `AudioPlayer.jsx`）
  - Props: `progressPercent`, `onClick`
  - 简单的 5px 进度条线，点击展开
  - 使用 MUI `Box` 组件

- [ ] **测试先行**：编写 `frontend/src/components/player/__tests__/FullAudioBar.test.jsx`
  - 测试展开态 UI 渲染（所有按钮、进度条、音量）
  - 测试播放/暂停按钮（调用 `togglePlay`）
  - 测试前进/后退按钮（调用 `skip`）
  - 测试倍速切换按钮（循环切换 1X → 1.25X → 1.5X → 0.75X → 1X）
  - 测试音量控制（滑块 + 静音按钮）
  - 测试三状态（所有按钮的 Normal/Hover/Active）

- [ ] **实现组件**：创建 `frontend/src/components/player/FullAudioBar.jsx`
  - 包含完整的展开态 UI
  - **内部直接包含所有按钮**（不拆分，采用逻辑聚合策略）：
    - 播放/暂停按钮（使用 `IconButton` + `PlayArrow`/`Pause` 图标）
    - 前进/后退按钮（使用 `IconButton` + `Replay` 图标，通过 `transform` 旋转实现）
    - 倍速切换按钮（使用 `Button`，点击切换 `playbackRate`）
    - 音量控制（包含音量滑块 `Slider` 和静音按钮 `IconButton`，直接写在组件内）
  - 引用 `ProgressBar` 组件（因为拖拽交互逻辑复杂，需要独立拆分）
  - 使用 `useAudio` hook 获取状态和操作方法

- [ ] **测试先行**：编写 `frontend/src/components/player/__tests__/AudioBarContainer.test.jsx`
  - 测试智能容器渲染（根据 `isIdle` 显示 Full 或 Mini）
  - 测试收缩逻辑（5s 无操作后显示 MiniAudioBar）
  - 测试展开逻辑（点击 MiniAudioBar 后显示 FullAudioBar）

- [ ] **实现组件**：创建 `frontend/src/components/player/AudioBarContainer.jsx`
  - 智能容器，负责检测鼠标活动
  - 使用 `useIdle` hook 判断是否收缩
  - 根据 `isCollapsed` 状态渲染 `FullAudioBar` 或 `MiniAudioBar`
  - Props: 透传所有音频控制相关的 props

- [ ] **重构 AudioPlayer**：更新 `frontend/src/components/AudioPlayer.jsx`
  - 简化为使用 `AudioBarContainer` 的包装组件
  - 保持向后兼容的 API（`audioUrl`, `onTimeUpdate`, `initialVolume`）
  - 更新测试：`components/__tests__/AudioPlayer.test.jsx`（保留集成测试）

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 组件拆分后功能完整（播放、暂停、进度控制、音量控制）
  - [ ] 收缩/展开逻辑正常工作
  - [ ] 所有按钮三状态正常（Normal/Hover/Active）
  - [ ] 向后兼容（现有使用 `AudioPlayer` 的代码无需修改）

---

#### Task 2.4：字幕同步 Hook
**优先级**: P0  
**预计工时**: 3 小时

- [ ] **测试先行**：编写 `frontend/src/hooks/__tests__/useSubtitleSync.test.js`
  - 测试根据 `currentTime` 找到当前激活的 cue
  - 测试自动滚动逻辑（当前字幕在可视区域外时自动滚动）
  - 测试用户滚动时停止自动滚动（5s 后恢复）
  - 测试划线操作时停止自动滚动

- [ ] **实现 Hook**：创建 `frontend/src/hooks/useSubtitleSync.js`
  - 实现字幕同步逻辑（根据 `currentTime` 高亮当前字幕）
  - 实现自动滚动逻辑（使用 `useRef` + `scrollIntoView`）
  - 实现用户交互检测（监听滚动事件，5s 无操作后恢复自动滚动）
  - 返回：`{ activeCueId, scrollToCue }`

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] Hook 可独立使用
  - [ ] 自动滚动逻辑流畅（无卡顿）

---

#### Task 2.5：字幕列表组件
**优先级**: P0  
**预计工时**: 5 小时

- [ ] **测试先行**：编写 `frontend/src/components/subtitles/__tests__/SubtitleList.test.jsx`
  - 测试组件渲染（渲染所有 cues）
  - 测试空状态（无字幕时显示提示）
  - 测试 Loading 状态（显示 Skeleton）

- [ ] **实现组件**：创建 `frontend/src/components/subtitles/SubtitleList.jsx`
  - 字幕列表容器
  - Props: `cues`, `currentTime`, `onSeek`, `highlights`, `onHighlightClick`
  - 使用 MUI `List` 组件
  - 循环渲染 `SubtitleRow` 组件
  - 集成 `useSubtitleSync` hook 实现自动滚动

- [ ] **测试先行**：编写 `frontend/src/components/subtitles/__tests__/SubtitleRow.test.jsx`
  - 测试单行字幕渲染（显示时间标签 + 文本 + speaker）
  - 测试当前字幕高亮（`isActive` 时背景色变化）
  - 测试点击跳转（调用 `onSeek` 回调）
  - 测试划线渲染（根据 `highlights` 显示下划线）
  - 测试三状态（Normal/Hover/Active）
  - 测试性能优化（使用 `React.memo` 避免不必要的重渲染）

- [ ] **实现组件**：创建 `frontend/src/components/subtitles/SubtitleRow.jsx`
  - 单行字幕组件（性能优化边界，必须独立拆分以配合 `React.memo`）
  - Props: `cue`, `isActive`, `onSeek`, `highlights`, `onHighlightClick`
  - 显示时间标签（左侧，与字幕顶端对齐，间距 10px）
  - 显示字幕文本（自动换行，字体 15px，左右缩进 8px，段后距 24px）
  - 显示 speaker 标签（单独占据一行，在 speaker 开始的第一句话上方）
  - 根据 `highlights` 渲染下划线（紫色，`#9C27B0`）
  - 使用 `React.memo` 优化渲染性能（避免 1000+ 行字幕列表卡顿）

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 字幕列表渲染流畅（1000+ 行无卡顿）
  - [ ] 当前字幕高亮正确
  - [ ] 点击字幕后音频跳转成功
  - [ ] 自动滚动逻辑正常工作
  - [ ] 字幕样式符合 PRD（时间标签、speaker 标签、间距）

---

#### Task 2.6：播客信息头部组件
**优先级**: P0  
**预计工时**: 2 小时

- [ ] **测试先行**：编写 `frontend/src/components/layout/__tests__/EpisodeHeader.test.jsx`
  - 测试组件渲染（显示 episode 标题和 show 名称）
  - 测试空状态（无 episode 时显示提示）

- [ ] **实现组件**：创建 `frontend/src/components/layout/EpisodeHeader.jsx`
  - 播客 episode 信息头部（PRD 6.2.2）
  - Props: `episode`（包含 `title`, `showName`）
  - 显示基础信息：靠左展示 episode 名称、show/channel 名称
  - 使用 MUI `Box` + `Typography` 组件
  - 位置：屏幕顶层矩形区域

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 组件正常渲染 episode 信息
  - [ ] 样式符合 PRD（靠左展示，字体大小适中）

---

#### Task 2.7：Episode 页面集成
**优先级**: P0  
**预计工时**: 4 小时

- [ ] **测试先行**：编写 `frontend/src/pages/__tests__/EpisodePage.test.jsx`
  - 测试页面渲染（从 URL 获取 `episode_id`）
  - 测试数据加载（调用 API 获取 Episode 详情）
  - 测试 Loading 状态（显示 Skeleton）
  - 测试 Error 状态（显示 Alert）
  - 测试音频与字幕同步（`currentTime` 传递）

- [ ] **实现页面**：创建 `frontend/src/pages/EpisodePage.jsx`
  - 从 URL 参数获取 `episode_id`（使用 React Router `useParams`）
  - 从 API 获取 Episode 详情（`GET /api/episodes/{id}`）
  - 渲染布局：
    - 顶部：`EpisodeHeader`（episode 信息）
    - 中间：`AudioPlayer`（音频控制）
    - 底部：`SubtitleList`（字幕列表，占据剩余空间，可滚动）
  - 实现音频与字幕同步：
    - `AudioPlayer` 的 `currentTime` → 传递给 `SubtitleList`
    - `SubtitleList` 的 `onSeek` → 更新 `AudioPlayer` 播放位置

- [ ] **状态管理**
  - 使用 `useState` 管理 `episode`, `cues`, `currentTime`, `highlights`
  - 使用 `useEffect` 拉取数据
  - 添加 Loading 状态（MUI `Skeleton` 组件）
  - 添加 Error 状态（MUI `Alert` 组件）

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 页面正常渲染
  - [ ] 音频播放时字幕同步高亮
  - [ ] 点击字幕后音频跳转
  - [ ] Loading 和 Error 状态正常显示
  - [ ] 布局符合 PRD（顶部信息 + 中间播放器 + 底部字幕）

---

#### Task 2.8：文件上传弹窗组件
**优先级**: P0  
**预计工时**: 5 小时

- [ ] **测试先行**：编写 `frontend/src/components/upload/__tests__/FileImportModal.test.jsx`
  - 测试弹窗渲染（显示标题栏 + 选择器）
  - 测试音频文件选择（点击路径填空条唤起系统文件选择器）
  - 测试字幕文件选择（点击路径填空条唤起系统文件选择器）
  - 测试字幕识别勾选框（勾选后字幕文件路径填空条置灰）
  - 测试自动填充字幕路径（如果音频文件路径下存在对应字幕文件）
  - 测试文件格式验证（MP3/WAV 音频，JSON 字幕）
  - 测试文件大小限制（超过 1GB 或 3 小时提示错误）
  - 测试弹窗关闭逻辑（点击关闭按钮或外部区域）

- [ ] **实现组件**：创建 `frontend/src/components/upload/FileImportModal.jsx`
  - 文件选择弹窗（PRD 6.1.1.b）
  - Props: `open`, `onClose`, `onConfirm`
  - 弹窗结构（PRD 119-130行）：
    - 标题栏：名字"音频和字幕选择弹框"，右侧关闭按钮
    - 选择器：
      - 选择音频文件路径填空条（PRD 123行）
      - 字幕识别勾选框（PRD 124行，先占位，不实际实现）
      - 选择字幕文件路径填空条（PRD 126行）
  - 交互逻辑（PRD 113-145行）：
    - 点击路径填空条 → 唤起系统文件选择器
    - 自动填充字幕路径（如果音频文件路径下存在对应字幕文件）
    - 文件格式验证（MP3/WAV 音频，JSON 字幕）
    - 文件大小限制（超过 1GB 或 3 小时提示错误）
    - 弹窗关闭逻辑（点击关闭按钮，点击外部区域闪烁提示）
  - 使用 MUI `Dialog` + `TextField` + `Checkbox` 组件

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 文件选择功能正常
  - [ ] 自动填充逻辑正确
  - [ ] 文件验证逻辑正确
  - [ ] 弹窗交互符合 PRD

---

#### Task 2.9：字幕识别进度遮罩组件
**优先级**: P0  
**预计工时**: 4 小时

- [ ] **测试先行**：编写 `frontend/src/components/upload/__tests__/ProcessingOverlay.test.jsx`
  - 测试遮罩渲染（显示提示文字 + 进度条）
  - 测试音频上传进度（显示上传进度条）
  - 测试字幕加载进度（显示加载进度条）
  - 测试字幕识别进度（显示识别进度条 + 控制按钮）
  - 测试错误状态（显示错误提示 + 重试图标）
  - 测试重试逻辑（点击重试图标重新上传/加载/识别）

- [ ] **实现组件**：创建 `frontend/src/components/upload/ProcessingOverlay.jsx`
  - 进度遮罩（PRD 6.1.2）
  - Props: `type`（"upload" | "load" | "recognize"）, `progress`, `error`, `onRetry`, `onCancel`
  - 显示逻辑（PRD 159-192行）：
    - 音频上传中：显示"请稍等，音频上传中" + 上传进度条
    - 字幕加载中：显示"请稍等，字幕加载中" + 加载进度条
    - 字幕识别中：显示"请稍等，努力识别字幕中" + 识别进度条 + 控制按钮（方形/三角形）
    - 错误状态：显示错误提示 + 重试图标（转圈箭头）
  - 进度条计算（PRD 162, 185行）：
    - 音频上传：如果音频文件时长为 X，上传速度为 0.1X，进度条按匀速显示
    - 字幕识别：如果音频文件时长为 X，总识别时间为 0.4X，进度条按匀速显示
  - 使用 MUI `Box` + `LinearProgress` + `CircularProgress` + `IconButton` 组件

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 进度条显示正确
  - [ ] 错误处理正常
  - [ ] 重试逻辑正确

---

#### Task 2.10：集成文件上传到 Episode 页面
**优先级**: P0  
**预计工时**: 3 小时

- [ ] **更新 EpisodePage**：集成文件上传功能
  - 在 `EpisodePage.jsx` 中添加"音频和字幕选择按钮"（PRD 110行，位置在音频控制面板"音量调节条"右侧）
  - 点击按钮 → 弹出 `FileImportModal`
  - 处理文件上传：
    - 调用 `POST /api/episodes/upload` 上传音频文件
    - 显示 `ProcessingOverlay`（上传进度）
    - 上传完成后加载字幕（如果提供了字幕文件）
    - 触发字幕识别（如果勾选了字幕识别）

- [ ] **处理首次打开逻辑**（PRD 142-144行）
  - 首次打开界面（没有选择过任何音频文件）→ 自动弹出 `FileImportModal`
  - 如果用户关闭弹窗 → 字幕识别区域居中显示"您还未选择音频文件，点击按钮进行选择" + "音频和字幕选择按钮"

- [ ] **处理已选择逻辑**（PRD 144行）
  - 用户已经选择过一次音频和字幕文件后 → 保持展示上次选择的内容
  - 不再主动弹出 `FileImportModal`

- [ ] **验收标准**
  - [ ] 文件上传功能正常
  - [ ] 首次打开逻辑正确
  - [ ] 已选择逻辑正确
  - [ ] 进度显示正常

---

### 阶段 3：划线 + 笔记功能（Week 3）

#### Task 3.1：文本选择 Hook（跨段落划线逻辑）
**优先级**: P0  
**预计工时**: 6 小时

- [ ] **测试先行**：编写 `frontend/src/hooks/__tests__/useTextSelection.test.js`
  - 测试单 cue 文本选择（选中一个 cue 内的文本）
  - 测试跨 cue 文本选择（选中多个 cue 的文本）
  - 测试选择范围计算（`startOffset`, `endOffset`, `affectedCues`）
  - 测试选择清除（点击外部区域清除选择）

- [ ] **实现 Hook**：创建 `frontend/src/hooks/useTextSelection.js`
  - 实现跨段落划线逻辑（监听鼠标事件完成文本选择）
  - 处理 `window.getSelection()` API
  - 计算选择范围（`startOffset`, `endOffset`）
  - 识别受影响的 cues（跨 cue 划线时自动拆分）
  - 返回：`{ selectedText, selectionRange, affectedCues, clearSelection }`
  - **关键逻辑**：跨 cue 划线时，自动拆分成多个 Highlight（每个 cue 一个）

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] Hook 可独立使用
  - [ ] 跨 cue 划线逻辑正确（自动拆分）

---

#### Task 3.2：划线操作菜单组件
**优先级**: P0  
**预计工时**: 4 小时

- [ ] **测试先行**：编写 `frontend/src/components/subtitles/__tests__/SelectionMenu.test.jsx`
  - 测试菜单渲染（显示三个按钮：纯划线、查询、想法）
  - 测试菜单定位（在划线源附近显示，屏幕不够用时自动调整位置）
  - 测试点击"纯划线"按钮（调用 `onUnderline` 回调）
  - 测试点击"查询"按钮（调用 `onQuery` 回调）
  - 测试点击"想法"按钮（调用 `onThought` 回调）
  - 测试三状态（按钮的 Normal/Hover/Active）

- [ ] **实现组件**：创建 `frontend/src/components/subtitles/SelectionMenu.jsx`
  - 划线操作菜单（PRD 6.2.4.b，定位逻辑复杂，需要独立拆分）
  - Props: `anchorPosition`, `onUnderline`, `onQuery`, `onThought`, `onClose`
  - 三个操作按钮（图标展示，无文字）：
    - 下划线图标 = "纯划线"
    - 放大镜 = "查询"
    - 灯泡 = "想法"
  - 位置计算逻辑（PRD 317行）：
    - 默认在划线源正上方 10px 处
    - 屏幕上方不够用 → 正下方 10px 处
    - 屏幕左边不够用 → 水平往右挪动
    - 屏幕右边不够用 → 水平往左挪动
  - 使用 MUI `Popover` 或自定义定位实现

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 菜单定位逻辑正确（各种屏幕边界情况）
  - [ ] 三个按钮交互正常
  - [ ] 按钮三状态正常（Normal/Hover/Active）

---

#### Task 3.3：集成文本选择到字幕组件
**优先级**: P0  
**预计工时**: 3 小时

- [ ] **更新 SubtitleList**：集成 `useTextSelection` hook
  - 在 `SubtitleList.jsx` 中使用 `useTextSelection` hook
  - 监听文本选择事件，显示 `SelectionMenu`
  - 处理划线操作回调（纯划线、查询、想法）

- [ ] **更新 SubtitleRow**：根据选择状态改变背景色
  - 在 `SubtitleRow.jsx` 中根据 `useTextSelection` 返回的状态改变背景色
  - 实现"隐形"的划线效果（选中文本时背景色变化）
  - 不创建单独的 `TextSelector` 组件（UI 组件只负责改变背景色）

- [ ] **验收标准**
  - [ ] 文本选择功能正常工作
  - [ ] 选中文本后弹出操作菜单
  - [ ] 菜单定位正确
  - [ ] 不影响字幕其他功能（高亮、滚动等）

---

#### Task 3.4：Highlight API（后端）
**优先级**: P0  
**预计工时**: 4 小时

- [ ] **测试先行**：编写 `backend/tests/test_highlight_api.py`
  - 测试创建划线（验证 `start_offset` 和 `end_offset`）
  - 测试单 cue 划线（`highlight_group_id = null`）
  - 测试跨 cue 划线（多个 Highlight 共享 `highlight_group_id`）
  - 测试获取划线列表
  - 测试删除划线（按组删除）
  - 测试级联删除：删除 Highlight 时自动删除关联的 Note 和 AIQueryRecord

- [ ] **实现 API**：在 `backend/app/api.py` 添加路由（⭐ 简化）
  ```python
  # POST /api/highlights
  # 功能：创建划线（前端已拆分，后端接收数组）⭐
  # 请求：{ 
  #   "episode_id": 1, 
  #   "highlights": [  # ⭐ 数组，前端已拆分
  #     {
  #       "cue_id": 10,
  #       "start_offset": 6,
  #       "end_offset": 12,
  #       "highlighted_text": "world.",
  #       "color": "#9C27B0"
  #     },
  #     {
  #       "cue_id": 11,
  #       "start_offset": 0,
  #       "end_offset": 15,
  #       "highlighted_text": "This is a test.",
  #       "color": "#9C27B0"
  #     }
  #   ],
  #   "highlight_group_id": "uuid-12345"  # ⭐ 可选，跨 cue 时提供
  # }
  # 响应：{ 
  #   "success": true,
  #   "highlight_ids": [1, 2],  # 创建的 Highlight ID 列表
  #   "highlight_group_id": "uuid-12345",  # 如果是分组
  #   "created_at": "..." 
  # }

  # GET /api/episodes/{id}/highlights
  # 功能：获取某个 Episode 的所有划线
  # 响应：[ 
  #   { 
  #     "id": 1, 
  #     "cue_id": 10,  # ⭐ 只有一个 cue_id
  #     "highlighted_text": "taxonomy", 
  #     "start_offset": 5, 
  #     "end_offset": 13,
  #     "color": "#9C27B0",
  #     "highlight_group_id": null,  # ⭐ 单 cue 划线
  #     "created_at": "2025-01-01T00:00:00Z",
  #     "updated_at": "2025-01-01T00:00:00Z"
  #   },
  #   ...
  # ]
  # 说明：
  # - 不包含 notes 字段（前端使用独立的 GET /api/episodes/{id}/notes API 获取）
  # - 符合 RESTful 设计原则，避免 N+1 查询问题

  # DELETE /api/highlights/{id}
  # 响应：{ 
  #   "success": true, 
  #   "deleted_highlights_count": 3,  # ⭐ 按组删除
  #   "deleted_notes_count": 2,
  #   "deleted_ai_queries_count": 1
  # }
  # 说明：
  # - 如果 Highlight 有 highlight_group_id，删除整组
  # - 级联删除关联的 Note 和 AIQueryRecord
  ```

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] Swagger 文档更新
  - [ ] 级联删除测试通过：删除 Highlight 后，关联的 Note 和 AIQueryRecord 被自动删除
  - [ ] 按组删除逻辑正确（跨 cue 划线时删除整组）

---

#### Task 3.5：纯划线功能（前端）
**优先级**: P0  
**预计工时**: 3 小时

- [ ] **测试先行**：编写 `frontend/src/components/subtitles/__tests__/UnderlineFeature.test.jsx`
  - 测试点击"纯划线"按钮（调用 API 创建 underline 类型的 Note）
  - 测试下划线样式生效（被划线的字幕出现紫色下划线）
  - 测试刷新页面后下划线保持（从 API 加载已有的 underline 笔记）

- [ ] **实现功能**：在 `SubtitleList.jsx` 中集成
  - 点击"纯划线"按钮 → 调用 `POST /api/highlights` 创建 Highlight
  - 调用 `POST /api/notes` 创建 `note_type = "underline"` 的 Note
  - 本地更新 UI（在文本上添加紫色下划线样式）
  - 从 API 加载已有的 underline 笔记，渲染下划线样式

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 点击"纯划线"后下划线样式生效
  - [ ] 刷新页面后下划线保持
  - [ ] underline 类型的笔记不显示笔记卡片（只显示下划线）

---

#### Task 3.6：笔记侧边栏组件
**优先级**: P0  
**预计工时**: 5 小时

- [ ] **测试先行**：编写 `frontend/src/components/notes/__tests__/NoteSidebar.test.jsx`
  - 测试侧边栏渲染（显示笔记列表）
  - 测试展开/收缩逻辑（点击箭头按钮）
  - 测试空状态（无笔记时显示提示 + 悬浮笔记图标）
  - 测试笔记列表循环（渲染所有 NoteCard）

- [ ] **实现组件**：创建 `frontend/src/components/notes/NoteSidebar.jsx`
  - 笔记侧边栏（PRD 6.2.4.g，包含侧边栏容器 + 笔记列表循环逻辑，不拆分列表组件）
  - Props: `notes`, `highlights`, `onNoteClick`, `onNoteDelete`
  - 元素：
    - 笔记区域收缩悬浮按钮（向右箭头图标，PRD 377行）
    - 笔记区域展开悬浮按钮（笔记图标气泡，PRD 379行）
    - 笔记区域内容容器（循环渲染 `NoteCard`）
  - 展示逻辑（PRD 382-384行）：
    - 无笔记时：默认不展开，显示悬浮笔记图标
    - 有笔记时：默认展开并保持展开状态
    - 用户主动收起后：维持收缩状态，除非用户主动展开
  - 使用 MUI `Box` + `Stack` 组件

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 展开/收缩逻辑正确
  - [ ] 笔记列表正常渲染
  - [ ] 样式符合 PRD（收缩按钮、展开按钮、内容容器）

---

#### Task 3.7：笔记卡片组件
**优先级**: P0  
**预计工时**: 6 小时

- [ ] **测试先行**：编写 `frontend/src/components/notes/__tests__/NoteCard.test.jsx`
  - 测试笔记卡片渲染（显示标题栏 + 内容区）
  - 测试编辑功能（点击 edit 图标进入编辑态）
  - 测试删除功能（点击垃圾桶图标弹出确认弹窗）
  - 测试删除确认弹窗（确认/取消按钮）
  - 测试点击笔记卡片（对应的划线源闪烁）
  - 测试三状态（Normal/Hover/Active）

- [ ] **实现组件**：创建 `frontend/src/components/notes/NoteCard.jsx`
  - 笔记卡片（PRD 6.2.4.h，包含展示态 + 编辑态 + 删除按钮逻辑；删除确认直接使用 `<Modal>` 组件）
  - Props: `note`, `highlight`, `onUpdate`, `onDelete`, `onClick`
  - 笔记卡片结构（PRD 404-416行）：
    - 标题栏（常驻，滚动不影响）：
      - 左侧：用户头像（demo 阶段 mock 数据）
      - 中间：edit 图标（距离头像 24px）
      - 右侧：垃圾桶图标
    - 内容区：
      - 笔记内容（支持自动换行）
      - 支持最小可行的排版（PRD 412-416行）：
        - 支持 enter 键入换行
        - 支持 `**语法加粗`
        - 其他均使用文本显示，不支持复杂排版
        - 过滤防止 JS 注入
  - 交互（PRD 418-424行）：
    - 单击笔记卡片容器 → 对应的划线源闪烁
    - 单击 edit 图标 → 内容区变成可编辑态
    - 单击垃圾桶图标 → 弹出删除确认弹窗（使用通用 `<Modal>` 组件）
  - 使用 MUI `Card` + `CardHeader` + `CardContent` 组件

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 笔记卡片正常渲染
  - [ ] 编辑功能正常（点击 edit 进入编辑态，点击外部提交修改）
  - [ ] 删除功能正常（弹出确认弹窗，确认后删除）
  - [ ] 点击笔记卡片后划线源闪烁
  - [ ] 笔记内容排版正确（换行、加粗）
  - [ ] 防止 JS 注入（过滤危险内容）

---

#### Task 3.8：笔记双向链接（前端集成）
**优先级**: P0  
**预计工时**: 4 小时

- [ ] **实现"始终跟随划线源"逻辑**（PRD 6.2.4.h.i）
  - 为每个 Highlight 计算其在左侧的垂直位置（`offsetTop`）
  - 在右侧对应位置渲染关联的 Note（PRD 390行："笔记卡片的顶部在用户的'划线源'顶部上面24px的位置"）
  - 监听左侧滚动事件 → 同步右侧笔记位置（使用 `IntersectionObserver`）

- [ ] **实现双向链接**（PRD 6.2.4.c）
  - 点击右侧笔记 → 左侧滚动到对应划线 + 高亮划线（PRD 329-330行）
  - 点击左侧划线 → 右侧滚动到对应笔记（如果存在）（PRD 322-330行）
  - 笔记卡片闪烁效果（使用 CSS animation）

- [ ] **集成到 EpisodePage**
  - 在 `EpisodePage.jsx` 中集成 `NoteSidebar` 组件
  - 实现左右分栏布局（左侧字幕 60%，右侧笔记 40%）
  - 实现双向链接逻辑

- [ ] **验收标准**
  - [ ] 笔记与划线源在同一水平线
  - [ ] 滚动时笔记跟随划线移动
  - [ ] 双向点击导航正常工作
  - [ ] 笔记卡片闪烁效果正常

---

#### Task 3.9：Note API（后端）
**优先级**: P0  
**预计工时**: 4 小时

- [ ] **测试先行**：编写 `backend/tests/test_note_api.py`
  - 测试创建笔记（三种类型：underline/thought/ai_card）
  - 测试更新笔记（修改 content）
  - 测试删除笔记（级联删除验证）
  - 测试获取笔记列表（按 episode_id 查询）

- [ ] **实现 API**：在 `backend/app/api.py` 添加路由
  ```python
  # POST /api/notes
  # 请求：{ 
  #   "episode_id": 1, 
  #   "highlight_id": 5, 
  #   "content": "...", 
  #   "note_type": "thought",
  #   "origin_ai_query_id": null  # 可选，AI 查询转笔记时提供
  # }
  # 响应：{ "id": 1, "created_at": "..." }

  # PUT /api/notes/{id}
  # 请求：{ "content": "..." }
  # 响应：{ "success": true }

  # DELETE /api/notes/{id}
  # 响应：{ "success": true }
  # 说明：删除 Note 不会删除 AIQueryRecord（反向关联）

  # GET /api/episodes/{id}/notes
  # 响应：[ 
  #   { 
  #     "id": 1, 
  #     "highlight_id": 5, 
  #     "content": "...", 
  #     "note_type": "thought",
  #     "origin_ai_query_id": null,
  #     "created_at": "...",
  #     "updated_at": "..."
  #   }, 
  #   ... 
  # ]
  ```

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] Swagger 文档更新
  - [ ] 三种笔记类型支持正确
  - [ ] 删除 Note 不影响 AIQueryRecord（反向关联测试通过）

---


### 阶段 4：AI 查询功能（Week 4）

#### Task 4.1：AI 查询服务（后端）
**优先级**: P1（重要）  
**预计工时**: 8 小时

- [ ] **测试先行**：编写 `backend/tests/test_ai_service.py`
  - 测试统一查询接口（传入划线文本，AI 自动判断类型）
  - 测试 JSON 响应解析（验证返回的 JSON 格式符合规范）
  - 测试类型检测（验证 AI 返回的 type 字段：word/phrase/sentence）
  - 测试单词查询（返回 word 类型，包含 phonetic/definition/explanation）
  - 测试短语查询（返回 phrase 类型，包含 phonetic/definition/explanation）
  - 测试句子查询（返回 sentence 类型，包含 translation/highlight_vocabulary）
  - 测试上下文构建（相邻 2-3 个 cue 的文本）
  - 测试错误处理（API 超时、无效 JSON 响应、JSON 格式错误）
  - **测试超时处理**（⭐ 新增）：
    - 测试查询超时（超过配置的超时时间未返回结果）
    - 验证超时错误返回 HTTP 504 状态码
    - 验证超时后 AIQueryRecord 状态更新为 "failed"
    - 验证超时错误信息包含"超时"关键词
  - 测试查询缓存（相同 highlight_id 的查询返回缓存）
  - 测试 JSON 解析失败处理（AI 返回非 JSON 格式时的错误处理）

- [ ] **选择 AI API**
  - 环境变量中有Gemini API key，调用gemini-2.5-flash模型；
  - 系统提示词：
    system_prompt = """
# Role
你是一名专业的英语语言教学助手，擅长以简洁、准确的方式向英语学习者解释语言知识。

# Task
接收用户的输入内容，首先判断其属于"词汇 (word)"、"短语 (phrase)"还是"句子 (sentence)"，然后按照指定的 JSON 格式输出教学内容。

# Constraints
1. 输出必须严格遵守 JSON 格式，不要包含Markdown代码块标记（如 ```json）。
2. 解释内容需简洁明了，适合英语学习者，总字数控制在 100 字以内。
3. 如果是专业术语，必须在解释中包含背景知识。

# Output Format (JSON)
{
    "type": "word | phrase | sentence", // 判断结果
    "content": {
        // 如果是 word 或 phrase，包含以下字段：
        "phonetic": "...", // 音标
        "definition": "...", // 中文释义
        "explanation": "...", // 详细解释/用法/背景知识
        
        // 如果是 sentence，包含以下字段：
        "translation": "...", // 整句中文翻译
        "highlight_vocabulary": [ // 难点词汇解析列表
            {"term": "...", "definition": "..."}
        ]
    }
}

# Few-Shot Examples

## Example 1: Word (词汇)
User Input: "Serendipity"
Assistant Output:
{
    "type": "word",
    "content": {
        "phonetic": "/ˌserənˈdɪpəti/",
        "definition": "意外发现珍宝的运气；机缘凑巧",
        "explanation": "这是一个非常优美的单词，指无意中发现有趣或有价值事物的能力。常用于描述那些美好的、意料之外的巧合或发现。"
    }
}

## Example 2: Phrase (短语)
User Input: "Black swan event"
Assistant Output:
{
    "type": "phrase",
    "content": {
        "phonetic": "/blæk swɒn ɪˈvent/",
        "definition": "黑天鹅事件",
        "explanation": "金融和经济学术语。指那些极其罕见、难以预测，但一旦发生就会造成极端严重后果的事件。背景源于人们原以为天鹅都是白的，直到发现黑天鹅。"
    }
}

## Example 3: Sentence (句子)
User Input: "The accumulation of capital is a prerequisite for investment."
Assistant Output:
{
    "type": "sentence",
    "content": {
        "translation": "资本的积累是投资的先决条件。",
        "highlight_vocabulary": [
            {"term": "accumulation", "definition": "积累；堆积"},
            {"term": "prerequisite", "definition": "先决条件；前提"},
            {"term": "investment", "definition": "投资"}
        ]
    }
}
"""

- [ ] **实现 AI 查询逻辑**（⭐ 优化：统一查询接口，AI 自动判断类型）
  ```python
  import json
  import google.generativeai as genai
  from app.config import GEMINI_API_KEY, DEFAULT_AI_PROVIDER
  
  class AIService:
      def __init__(self):
          genai.configure(api_key=GEMINI_API_KEY)
          self.model = genai.GenerativeModel('gemini-2.0-flash-exp')
      
      def query(self, text: str, context: str = None, provider: str = None) -> dict:
          """
          统一查询接口：传入划线文本，AI 自动判断是 word/phrase/sentence
          
          Args:
              text: 用户划线的文本
              context: 相邻 2-3 个 TranscriptCue 的文本（可选，用于专有名词识别）
              provider: AI 提供商（默认从 config.DEFAULT_AI_PROVIDER 获取，当前仅支持 Gemini）
          
          Returns:
              dict: 解析后的 JSON 对象，格式为：
              {
                  "type": "word" | "phrase" | "sentence",
                  "content": {
                      # word/phrase: {phonetic, definition, explanation}
                      # sentence: {translation, highlight_vocabulary}
                  }
              }
          
          Raises:
              TimeoutError: 查询超时（超过配置的超时时间）
              ValueError: JSON 解析失败或格式不符合规范
              Exception: API 调用失败
          """
          # 构建 prompt
          system_prompt = """# Role
你是一名专业的英语语言教学助手，擅长以简洁、准确的方式向英语学习者解释语言知识。

# Task
接收用户的输入内容，首先判断其属于"词汇 (word)"、"短语 (phrase)"还是"句子 (sentence)"，然后按照指定的 JSON 格式输出教学内容。

# Constraints
1. 输出必须严格遵守 JSON 格式，不要包含Markdown代码块标记（如 ```json）。
2. 解释内容需简洁明了，适合英语学习者，总字数控制在 100 字以内。
3. 如果是专业术语，必须在解释中包含背景知识。

# Output Format (JSON)
{
    "type": "word | phrase | sentence",
    "content": {
        // 如果是 word 或 phrase，包含以下字段：
        "phonetic": "...",
        "definition": "...",
        "explanation": "...",
        
        // 如果是 sentence，包含以下字段：
        "translation": "...",
        "highlight_vocabulary": [
            {"term": "...", "definition": "..."}
        ]
    }
}"""
          
          user_prompt = text
          if context:
              user_prompt = f"上下文：{context}\n\n查询内容：{text}"
          
          # 调用 Gemini API（带超时控制）⭐ 新增
          # 使用 ThreadPoolExecutor 和 Future.result(timeout=...) 实现超时
          from concurrent.futures import ThreadPoolExecutor, TimeoutError as FutureTimeoutError
          from app.config import AI_QUERY_TIMEOUT
          
          executor = ThreadPoolExecutor(max_workers=1)
          try:
              future = executor.submit(
                  self.client.models.generate_content,
                  model=self.model_name,
                  contents=full_prompt
              )
              response = future.result(timeout=AI_QUERY_TIMEOUT)
          except FutureTimeoutError:
              raise TimeoutError(f"AI 查询超时：超过 {AI_QUERY_TIMEOUT} 秒未返回结果，请稍后重试")
          finally:
              executor.shutdown(wait=False)
          
          # 解析 JSON（Gemini 可能返回带 Markdown 代码块的格式）
          response_text = response.text.strip()
          if response_text.startswith("```json"):
              response_text = response_text[7:]
          if response_text.startswith("```"):
              response_text = response_text[3:]
          if response_text.endswith("```"):
              response_text = response_text[:-3]
          response_text = response_text.strip()
          
          # 解析 JSON
          try:
              result = json.loads(response_text)
              # 验证格式
              if "type" not in result or "content" not in result:
                  raise ValueError("AI 返回的 JSON 格式不符合规范：缺少 type 或 content 字段")
              if result["type"] not in ["word", "phrase", "sentence"]:
                  raise ValueError(f"AI 返回的 type 字段值无效：{result['type']}")
              
              return result
          except json.JSONDecodeError as e:
              raise ValueError(f"AI 返回的内容不是有效的 JSON：{e}") from e
  ```

- [ ] **实现 API**：在 `backend/app/api.py` 添加路由（⭐ 优化：移除 query_type 参数，返回结构化 JSON）
  ```python
  # POST /api/ai/query
  # 请求：{ 
  #   "highlight_id": 5,
  #   "provider": "gemini-2.5-flash"  # 可选，默认从 config 获取
  # }
  # 响应：{ 
  #   "query_id": 1,
  #   "status": "completed",  # processing/completed/failed
  #   "response": {  # ⭐ 结构化 JSON 对象（不是字符串）
  #     "type": "word",  # word/phrase/sentence（由 AI 判断）
  #     "content": {
  #       "phonetic": "/ˌserənˈdɪpəti/",
  #       "definition": "意外发现珍宝的运气；机缘凑巧",
  #       "explanation": "..."
  #     }
  #   }
  # }
  # 说明：
  # - 先检查缓存（AIQueryRecord 表，基于 highlight_id）
  # - 如果已有缓存且 status="completed"，解析 response_text（JSON 字符串）并返回
  # - 如果没有缓存，创建 AIQueryRecord（status="processing"），调用 AI API
  # - 保存 response_text（JSON 字符串）和 detected_type（解析得到的 type 字段）
  # - 更新 AIQueryRecord（status="completed" 或 "failed"）
  # - 返回解析后的 JSON 对象（前端直接使用，无需再次解析）
  # - **超时处理**（⭐ 新增）：
  #   - 捕获 TimeoutError 异常
  #   - 返回 HTTP 504 状态码（Gateway Timeout）
  #   - 更新 AIQueryRecord 状态为 "failed"，记录超时错误信息
  ```

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] AI 能正确判断划线内容是 word/phrase/sentence（准确率 > 95%）
  - [ ] JSON 响应格式符合规范（包含 type 和 content 字段）
  - [ ] word/phrase 类型返回 phonetic/definition/explanation
  - [ ] sentence 类型返回 translation/highlight_vocabulary
  - [ ] 短语解释包含上下文理解（context_text 正确传递）
  - [ ] API 响应时间 < 3 秒（正常情况）
  - [ ] **超时处理正常工作**（⭐ 新增）：
    - 超过配置的超时时间（默认 30 秒）未返回结果时，触发超时错误
    - 超时错误返回 HTTP 504 状态码
    - AIQueryRecord 状态正确更新为 "failed"
    - 超时错误信息包含"超时"关键词
  - [ ] 查询缓存正常工作（相同 highlight_id 返回缓存结果）
  - [ ] JSON 解析失败时返回友好错误信息
  - [ ] detected_type 字段正确存储（用于索引和查询）

---

#### Task 4.2：AI 查询卡片组件
**优先级**: P1  
**预计工时**: 6 小时

- [ ] **测试先行**：编写 `frontend/src/components/subtitles/__tests__/AICard.test.jsx`
  - 测试卡片渲染（显示标题栏 + 内容区域）
  - 测试流式输出效果（模拟内容从少变多）
  - 测试卡片定位（在划线源附近，自动调整位置）
  - 测试卡片退出逻辑（点击外部消失、滚动划线源到屏幕外消失）
  - 测试"添加到笔记"按钮（点击后创建 Note，卡片消失）
  - **测试错误状态显示**（⭐ 新增）：
    - 测试超时错误时显示"AI查询失败"提示
    - 测试错误状态下卡片内容区域显示错误信息

- [ ] **实现组件**：创建 `frontend/src/components/subtitles/AICard.jsx`
  - AI 查询卡片（PRD 6.2.4.e，独立数据流，需要独立拆分）
  - Props: `anchorPosition`, `queryText`, `responseData`, `isLoading`, `onAddToNote`, `onClose` ⭐ 优化
    - `responseData`: 结构化的 JSON 对象（`{type: "word"|"phrase"|"sentence", content: {...}}`），不再是字符串
  - 卡片结构（PRD 353-359行）：
    - 标题栏（固定，滚动不影响）：
      - 左侧：AI 查询图标（loading 时转圈图标，完成时打勾图标）
      - 中间：标题"AI查询"
      - 右侧：笔记图标（点击后添加到笔记）
    - 内容区域（可滚动，最大高度为屏幕一半）：⭐ 优化：根据 type 渲染不同内容
      - **word/phrase 类型**：显示音标（phonetic）、释义（definition）、解释（explanation）
      - **sentence 类型**：显示翻译（translation）、难点词汇列表（highlight_vocabulary）
      - 流式输出文字内容（模拟从少变多）
      - 支持垂直滚动（内容超过最大高度时）
  - 卡片样式（PRD 352行）：
    - 固定宽度 420px
    - 最小高度 40px，最大高度为屏幕一半
    - 内容流式输出时高度逐渐增长
  - 卡片定位（PRD 361-367行）：
    - 垂直方向：划线位置在上 1/2 处 → 卡片在下方 10px；在下 1/2 处 → 卡片在上方 10px
    - 水平方向：与划线源中心对齐，超出屏幕时自动调整
  - 卡片退出逻辑（PRD 368-369行）：
    - 点击卡片外部 → 卡片消失
    - 滚动屏幕把划线源滚动到屏幕外 → 卡片消失
  - **错误状态处理**（⭐ 新增）：
    - 当 `isLoading=false` 且 `responseData=null` 时，显示"AI查询失败"提示
    - 错误提示使用红色文字（`color="error"`）
    - 超时错误时，卡片在 3 秒后自动消失
  - 使用 MUI `Card` + `CardHeader` + `CardContent` 组件

- [ ] **验收标准**
  - [ ] 所有测试用例通过
  - [ ] 卡片定位逻辑正确（各种屏幕边界情况）
  - [ ] 流式输出效果正常（模拟内容增长）
  - [ ] 卡片退出逻辑正确
  - [ ] 点击"添加到笔记"后卡片消失，笔记显示在右侧
  - [ ] **错误状态显示正常**（⭐ 新增）：
    - 超时错误时显示"AI查询失败"提示
    - 错误提示样式正确（红色文字）
    - 超时错误时卡片在 3 秒后自动消失

---

#### Task 4.3：集成 AI 查询到划线菜单
**优先级**: P1  
**预计工时**: 3 小时

- [ ] **更新 SelectionMenu**：添加 AI 查询回调
  - 在 `SelectionMenu.jsx` 中，点击"查询"按钮 → 调用 `onQuery` 回调
  - 传递选择范围信息（`selectedText`, `affectedCues`）

- [ ] **更新 SubtitleList**：集成 AI 查询逻辑（⭐ 优化：处理结构化 JSON 响应 + 超时处理）
  - 在 `SubtitleList.jsx` 中处理 AI 查询：
    - 点击"查询"按钮 → 调用 `POST /api/ai/query`（只需传入 `highlight_id`，无需 `query_type`）
    - API 返回结构化 JSON 对象（`{query_id, status, response: {type, content}}`）
    - 显示 `AICard` 组件（Loading 状态 → 显示结果）
    - 传递 `responseData` prop（解析后的 JSON 对象，不是字符串）
    - 处理流式输出（模拟内容增长）
  - **超时错误处理**（⭐ 新增）：
    - 检测超时错误（HTTP 504 或错误信息包含"超时"）
    - 超时错误时：显示 AICard，设置 `responseData=null` 显示"AI查询失败"提示
    - 3 秒后自动关闭 AICard（使用 `setTimeout`）
    - **不删除 highlight**（保留划线以便用户重试）
    - 其他错误：显示 Snackbar 提示，关闭 AICard，删除 highlight
  - 实现"添加到笔记"功能：
    - 点击 AICard 的笔记图标 → 调用 `POST /api/notes`（`note_type = "ai_card"`, `origin_ai_query_id` 关联）
    - Note 的 `content` 字段：根据 `responseData.type` 格式化内容
      - word/phrase: 显示 `definition + explanation`
      - sentence: 显示 `translation + highlight_vocabulary`（格式化列表）
    - 创建 Highlight（如果还没有）
    - 更新 UI（AICard 消失，笔记显示在右侧，划线源出现下划线）

- [ ] **验收标准**
  - [ ] AI 查询流程完整（划线 → 点击查询 → 显示卡片 → 添加到笔记）
  - [ ] 流式输出效果正常
  - [ ] 添加到笔记后立即显示
  - [ ] 划线源下划线样式生效
  - [ ] **超时错误处理正常**（⭐ 新增）：
    - 超时错误时，AICard 显示"AI查询失败"提示
    - 3 秒后 AICard 自动消失
    - 超时错误时，highlight 保留（用户可以重新查询）
    - 其他错误时，显示 Snackbar 提示并删除 highlight

---

#### Task 4.4：AI 查询流式输出优化
**优先级**: P2（可选优化）  
**预计工时**: 3 小时

- [ ] **实现流式输出**（如果后端支持 SSE）
  - 使用 `EventSource` 或 `fetch` + `ReadableStream` 接收流式数据
  - 实时更新 `AICard` 内容（逐字符显示）
  - 处理流式输出错误（连接中断、超时）

- [ ] **实现模拟流式输出**（如果后端不支持 SSE）
  - 后端返回完整结果后，前端模拟逐字符显示
  - 使用 `setTimeout` 或 `requestAnimationFrame` 实现动画效果
  - 提供配置项控制流式输出速度

- [ ] **验收标准**
  - [ ] 流式输出效果流畅（无卡顿）
  - [ ] 错误处理正常（连接中断时显示错误提示）
  - [ ] 用户体验良好（用户能看到内容逐渐增长）

---

### 阶段 5：完善与优化（Week 5+）

#### Task 5.1：错误处理与用户反馈
**优先级**: P1  
**预计工时**: 4 小时

- [ ] **后端统一异常处理**
  - 在 `backend/app/main.py` 添加全局异常处理器
  - 对所有 `HTTPException` 返回标准格式：
    ```json
    { "error": "错误信息", "code": "ERROR_CODE", "details": {} }
    ```

- [ ] **前端 Toast 通知**
  - 创建 `frontend/src/components/ToastProvider.jsx`（使用 MUI `Snackbar`）
  - 在所有 API 调用失败时显示 Toast
  - 成功操作也显示提示（如「笔记已保存」）

- [ ] **验收标准**
  - [ ] 所有错误都有友好提示
  - [ ] 无 Silent Failure

---

#### Task 5.2：性能优化
**优先级**: P2（中等）  
**预计工时**: 6 小时

- [ ] **后端优化**
  - 大文件转录采用分片处理（每 5 分钟一个分片）
  - 数据库添加索引：
    - `episodes.podcast_id`
    - `transcript_segments.episode_id`
    - `highlights.segment_id`
    - `notes.highlight_id`

- [ ] **前端优化**
  - 长字幕列表使用虚拟滚动（`react-window`）
  - 划线和笔记数据使用 `useMemo` 缓存
  - 图片懒加载（MUI `LazyLoad`）

- [ ] **验收标准**
  - [ ] 转录 30 分钟音频 < 10 分钟
  - [ ] 渲染 1000+ 字幕片段无卡顿
  - [ ] 内存占用 < 500MB

---

#### Task 5.3：文档更新
**优先级**: P2  
**预计工时**: 2 小时

- [ ] **每个任务完成后更新 `docs/changelog.md`**
  - 格式：`[2025-12-23] [feat] - 实现字幕划线功能 (TranscriptView.jsx, api.py)`

- [ ] **更新 README**
  - 添加项目介绍
  - 添加安装步骤
  - 添加使用说明

- [ ] **API 文档**
  - 访问 `http://localhost:8000/docs` 查看 Swagger 文档
  - 截图保存到 `docs/api_docs.png`

---

## 四、开发节奏

| 周次 | 阶段 | 核心目标 | 产出 |
|------|------|----------|------|
| **Week 1** | 后端数据层 + Whisper | 搭建后端核心功能 | - **7 个数据库表**创建成功<br>- **虚拟分段 + 临时文件转录**实现<br>- **文件去重**（MD5 hash）<br>- Episode 管理 API 完成<br>- 所有后端测试通过 |
| **Week 2** | 前端播放器 + 字幕展示 | 实现音频播放和字幕同步 | - AudioPlayer 组件完成<br>- TranscriptView 组件完成（含 speaker 显示）<br>- EpisodePage 页面完成<br>- 音频与字幕实时同步 |
| **Week 3** | 划线 + 笔记基础功能 | 实现核心交互 | - 字幕划线功能完成<br>- **三种笔记类型**（underline/thought/ai_query）<br>- 笔记创建/编辑/删除完成<br>- 双向链接完成<br>- 笔记与划线源对齐 |
| **Week 4** | AI 查询 + 优化 | 完善 AI 功能 | - AI 查询功能完成<br>- 错误处理完善<br>- 性能优化完成<br>- **MVP 版本发布** |
| **Week 5+** | iPad 适配 + 高级功能 | 跨平台支持 | - 响应式布局完成<br>- Touch 交互优化<br>- 笔记搜索功能<br>- 笔记导出功能 |

---

## 五、关键技术决策

### 5.1 虚拟分段 + 临时文件（存储优化）⭐
**决策**：不物理切割音频文件，只在数据库中记录时间范围，转录时用 FFmpeg 实时提取片段到临时文件  
**理由**：
- 节省 50% 存储空间（只保留一份完整音频）
- 灵活性强：可随时调整分段策略（如改为 5 分钟一段）
- Python `tempfile.NamedTemporaryFile` 自动清理临时文件

**实现**（修正版 ⚠️）：
```python
with tempfile.NamedTemporaryFile(suffix=".wav", delete=True) as temp:
    subprocess.run([
        "ffmpeg", "-y", "-i", audio_path, 
        "-ss", str(start_time), 
        "-t", str(duration),
        # ⚠️ 不使用 -c copy！MP3 只能在关键帧切割，时间戳不精确
        "-ar", "16000",      # Whisper 需要 16kHz
        "-ac", "1",          # 单声道
        "-c:a", "pcm_s16le", # PCM 编码，精准切割
        temp.name
    ], check=True)
    cues = whisper_service.transcribe(temp.name)
# 临时文件自动删除
```

**关键技术修正**（Critical ⚠️）：
- **禁止使用 `-c copy`**：
  - MP3 是压缩格式，只能在关键帧（Keyframe）处切割
  - 如果指定的 `start_time` 不是关键帧，FFmpeg 会寻找最近的关键帧
  - 导致切出的音频有几秒偏差，Whisper 识别的时间戳整体偏移
  - 后果：字幕和音频对不上（严重 Bug）

- **改用 WAV（PCM）格式**：
  - 秒级精准切割（无关键帧限制）
  - Whisper 内部也需要转为 16kHz Mono，提前转码节省加载时间
  - 性能影响：3 分钟片段转码 < 2 秒（完全可接受）

### 5.1.1 临时文件清理策略（避免磁盘占用过高）

**问题**：
- 转录失败时，临时文件会保留在 `backend/data/temp_segments/` 中
- 如果不清理，磁盘占用会持续增长
- 孤儿文件（对应的 Segment 已删除或长时间未重试）会永久占用空间

**清理策略**：
1. **成功转录后立即删除**：转录成功后，立即删除临时文件，清空 `segment_path`
2. **失败后保留 30 分钟**：给用户足够的短期重试时间（WAV 文件较大，不宜长期保留）
3. **定期后台清理**：每 15 分钟运行一次清理任务

**实现**：
```python
# backend/app/services/cleanup_service.py
import os
from datetime import datetime, timedelta
from app.database import get_db
from app.models import AudioSegment

def cleanup_orphan_temp_files():
    """清理孤儿临时文件（超过 30 分钟的失败转录）"""
    db = next(get_db())
    cutoff_time = datetime.utcnow() - timedelta(minutes=30)
    
    # 1. 查找所有超过 30 分钟的 failed Segment
    old_failed_segments = db.query(AudioSegment).filter(
        AudioSegment.status == "failed",
        AudioSegment.created_at < cutoff_time,
        AudioSegment.segment_path != None
    ).all()
    
    for segment in old_failed_segments:
        # 2. 删除临时文件
        if os.path.exists(segment.segment_path):
            os.remove(segment.segment_path)
        
        # 3. 清空路径
        segment.segment_path = None
    
    db.commit()
    
    # 4. 清理孤儿文件（文件存在但数据库中无对应记录）
    temp_dir = "backend/data/temp_segments/"
    if os.path.exists(temp_dir):
        for filename in os.listdir(temp_dir):
            file_path = os.path.join(temp_dir, filename)
            file_age = datetime.utcnow() - datetime.fromtimestamp(os.path.getmtime(file_path))
            
            # 超过 30 分钟的文件
            if file_age > timedelta(minutes=30):
                # 检查数据库中是否存在对应的 Segment
                segment = db.query(AudioSegment).filter(
                    AudioSegment.segment_path == file_path
                ).first()
                
                # 如果不存在，说明是孤儿文件，删除
                if not segment:
                    os.remove(file_path)
```

**定时任务**（使用 APScheduler）：
```python
# backend/app/scheduler.py
from apscheduler.schedulers.background import BackgroundScheduler
from app.services.cleanup_service import cleanup_orphan_temp_files

scheduler = BackgroundScheduler()

# 每 15 分钟运行一次清理任务
scheduler.add_job(
    cleanup_orphan_temp_files,
    'interval',
    minutes=15
)

scheduler.start()
```

**优势**：
- 自动清理过期临时文件，避免磁盘占用过高
- 给用户足够的短期重试时间（30 分钟）
- 快速释放磁盘空间（WAV 文件较大，3分钟片段约 30-50MB）
- 清理孤儿文件，防止数据泄漏

### 5.2 文件去重（MD5 hash + 异步计算）⚠️
**决策**：使用 MD5 hash 标识音频文件，避免重复存储  
**理由**：
- 相同文件只存储一次（节省空间）
- 用户重复上传时直接加载已有数据（提升体验）
- MD5 计算速度快（100MB 文件 < 5 秒）

**实现**（修正版 - 必须异步）：
```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

executor = ThreadPoolExecutor()

def calculate_md5_sync(file_path: str) -> str:
    """同步版本的 MD5 计算（在线程池中执行）"""
    hash_md5 = hashlib.md5()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):  # 1MB chunks
            hash_md5.update(chunk)
    return hash_md5.hexdigest()

@app.post("/upload")
async def upload_file(file: UploadFile):
    # 先保存到临时文件
    temp_path = f"/tmp/{file.filename}"
    with open(temp_path, "wb") as f:
        shutil.copyfileobj(file.file, f)
    
    # 异步计算 MD5（不阻塞其他请求）
    loop = asyncio.get_event_loop()
    file_hash = await loop.run_in_executor(executor, calculate_md5_sync, temp_path)
    # ...
```

**关键技术修正**（Critical ⚠️）：
- **必须使用 ThreadPoolExecutor**：
  - 问题：即使分块读取，MD5 计算是 CPU 密集型任务，受 Python GIL 限制
  - 影响：上传 500MB 文件计算 MD5 需要 20-30 秒，期间主线程被阻塞
  - 后果：其他用户的 API 请求（如获取字幕）会被卡住，无响应
  - 解决：`run_in_executor` 将计算扔到线程池，释放主线程处理其他请求

### 5.3 异步转录
**决策**：使用 FastAPI `BackgroundTasks` 处理 Whisper 转录  
**理由**：避免阻塞 API，提升用户体验（前端可以轮询状态）

### 5.4 字幕数据结构（Cue）
**决策**：使用 `TranscriptCue` 表，包含 `speaker` 字段，对应 PRD 的 cue 结构  
**理由**：
- 与 PRD 术语保持一致（cue，不是 segment）
- 支持说话人标识（PRD 必需）
- Whisper 使用 `word_timestamps=True` 提供精准时间戳

### 5.4.1 Episode 表优化（消除数据冗余）⭐ 新增
**决策**：删除 `Episode.show_name` 字段，使用 `@property` 动态获取（方案 1）  
**理由**：
- **消除数据冗余**：`show_name` 与 `Podcast.title` 本质相同，违反 3NF 范式
- **保证数据一致性**：修改 Podcast.title 时无需同步更新所有 Episode
- **简化数据维护**：无需编写同步逻辑
- **性能影响可控**：SQLAlchemy `joinedload` 可避免 N+1 查询，数据量不大时 JOIN 性能可忽略

**实现**：
```python
class Episode(Base):
    podcast = relationship("Podcast", back_populates="episodes")
    
    @property
    def show_name(self):
        """动态获取节目名称"""
        return self.podcast.title if self.podcast else "本地音频"
```

**查询优化**：
```python
# 使用 joinedload 避免 N+1 查询
episodes = db.query(Episode).options(joinedload(Episode.podcast)).all()
for episode in episodes:
    print(episode.show_name)  # 高效访问，无额外查询
```

### 5.4.2 分段信息全局配置（便于实验调优）⭐ 新增
**决策**：删除 Episode 表的分段相关字段（needs_segmentation、segment_duration、total_segments），改为全局配置 + @property  
**理由**：
- **大多数音频都需要分段**：单独存储 `needs_segmentation` 意义不大
- **分段阈值是系统级参数**：不是每个 Episode 独立配置，应集中管理
- **需要频繁调整以找最优值**：平衡转录速度和用户体验
- **便于实验**：修改 `config.py` 后，所有 Episode 自动生效，无需更新数据库
- **消除数据冗余**：派生属性不应存储，符合单一数据源原则

**实现**：
```python
# backend/app/config.py
SEGMENT_DURATION = 180  # 全局配置，可调整

# backend/app/models.py
class Episode(Base):
    duration = Column(Float, nullable=False)  # 只存储固有属性
    
    @property
    def segment_duration(self):
        from app.config import SEGMENT_DURATION
        return SEGMENT_DURATION
    
    @property
    def needs_segmentation(self):
        return self.duration > self.segment_duration
    
    @property
    def total_segments(self):
        if not self.needs_segmentation:
            return 1
        import math
        return math.ceil(self.duration / self.segment_duration)
```

**实验流程**：
```python
# 实验 1：测试 120 秒分段
SEGMENT_DURATION = 120  # 修改配置，重启服务
# 所有 Episode 自动使用新值

# 实验 2：测试 300 秒分段
SEGMENT_DURATION = 300  # 修改配置，重启服务
# 无需更新数据库，立即生效
```

**短音频 vs 长音频处理对比**（Critical）：

| 特性 | 短音频（150秒） | 长音频（600秒） |
|------|----------------|----------------|
| **Episode 属性** | | |
| `duration` | 150.0 | 600.0 |
| `needs_segmentation` | False（@property） | True（@property） |
| `total_segments` | 1（@property） | 4（@property） |
| **AudioSegment** | | |
| 创建数量 | ✅ 1 个 | ✅ 4 个 |
| `segment_index` | 0 | 0, 1, 2, 3 |
| `segment_id` | "segment_000" | "segment_000", "segment_001", "segment_002", "segment_003" |
| `start_time` | 0.0 | 0, 180, 360, 540 |
| `end_time` | 150.0 | 180, 360, 540, 600 |
| **TranscriptCue** | | |
| `segment_id` | 全部指向 segment_000 | 分别指向不同的 segment |
| `start_time` | 0.0, 5.0, 10.0, ... | 按时间排序（ORDER BY start_time） |
| **转录流程** | ✅ 相同 | ✅ 相同 |
| **状态管理** | ✅ 相同 | ✅ 相同 |
| **重试机制** | ✅ 相同 | ✅ 相同 |

**关键设计原则：统一处理**
- ✅ **所有音频都创建 AudioSegment**（短音频 1 个，长音频多个）
- ✅ **所有 TranscriptCue 都有 segment_id**（除非手动导入）
- ✅ **转录流程完全统一**：无需判断短音频 vs 长音频
- ✅ **代码极大简化**：一套流程适用所有场景

**完整示例**：
```python
# 短音频示例（150 秒）
Episode(id=1, duration=150.0)
  → needs_segmentation: False
  → total_segments: 1
  → AudioSegment(id=1, segment_index=0, start_time=0.0, end_time=150.0, segment_id="segment_000")
    → TranscriptCue(id=1, segment_id=1, cue_index=1, start_time=0.28, text="First sentence")
    → TranscriptCue(id=2, segment_id=1, cue_index=2, start_time=2.5, text="Second sentence")
    → TranscriptCue(id=3, segment_id=1, cue_index=3, start_time=5.0, text="Third sentence")

# 长音频示例（600 秒）
Episode(id=2, duration=600.0)
  → needs_segmentation: True
  → total_segments: 4
  → AudioSegment(id=2, segment_index=0, start_time=0.0, end_time=180.0, segment_id="segment_000")
    → TranscriptCue(id=4, segment_id=2, cue_index=1, start_time=0.5, text="...")
  → AudioSegment(id=3, segment_index=1, start_time=180.0, end_time=360.0, segment_id="segment_001")
    → TranscriptCue(id=5, segment_id=3, cue_index=2, start_time=180.8, text="...")
  → AudioSegment(id=4, segment_index=2, start_time=360.0, end_time=540.0, segment_id="segment_002")
    → TranscriptCue(id=6, segment_id=4, cue_index=3, start_time=360.3, text="...")
  → AudioSegment(id=5, segment_index=3, start_time=540.0, end_time=600.0, segment_id="segment_003")
    → TranscriptCue(id=7, segment_id=5, cue_index=4, start_time=540.1, text="...")
```

### 5.4.3 字幕排序最终方案（无 cue_index）⭐ 最终确定
**决策**：移除 `cue_index` 存储字段，查询时使用 `ORDER BY start_time ASC`  
**理由**：
- **降低维护成本**：在异步/并发转录场景下，维护全局连续的整数索引（Re-indexing）极其复杂且易死锁。
- **性能足够**：数据库对 `Float` 类型的索引排序极快，无需额外的整数列。
- **前端适配**：前端仅需展示序号时，在内存中动态计算（Index + 1）即可。
- **关联稳定性**：Highlight 严格关联 `cue.id`（主键），完全不受排序逻辑影响。

**实现**：
```python
# TranscriptCue：只存时间，不存 index
class TranscriptCue(Base):
    start_time = Column(Float, nullable=False, index=True)
    # cue_index = Column(Integer)  <-- DELETE

# 查询逻辑
def get_cues(episode_id):
    return db.query(TranscriptCue).filter(
        TranscriptCue.episode_id == episode_id
    ).order_by(TranscriptCue.start_time).all()

# 前端显示（动态计算序号）
cues.map((cue, index) => ({
    ...cue,
    displayIndex: index + 1  // 1, 2, 3, 4...
}))

# Highlight 关联（Critical ⭐⭐⭐）
class Highlight(Base):
    cue_id = Column(Integer, ForeignKey("transcript_cues.id"))  # ⭐ 使用主键
    # 完全不依赖排序逻辑，关联永不漂移
```

**并发安全**：

* 由于不再需要读取旧的最大 Index 并重新排号，`save_cues_to_db` 变成了纯粹的 `INSERT` 操作，天然并发安全，无需锁表。

### 5.4.4 用户体验设计原则："无感知"异步转录 ⭐⭐⭐ 新增
**决策**：用户完全无感知音频被切分和异步转录的实现细节  
**理由**：
- **PRD 核心需求**：用户上传音频 → 看到字幕依次展示 → 划线 → 生成笔记 → 下次打开笔记按顺序展示
- **用户不关心**：音频被切成几段、哪段先转录完成、转录失败重试
- **用户只关心**：字幕和笔记是否按正确顺序展示

**实现策略**：
1. **字幕顺序保证**：
   - 后端：使用 `start_time` 排序，查询时使用 `ORDER BY start_time ASC`
   - 前端：按 `start_time` 排序展示，序号动态计算（index + 1）
   - 结果：用户看到的字幕始终按时间顺序，无乱序

2. **笔记顺序保证**：
   - Highlight 使用 `cue.id`（主键）关联，完全不受排序逻辑影响
   - 笔记通过 `Highlight → TranscriptCue` 关联链，按 `start_time` 排序
   - 结果：用户下次打开时，笔记仍然按正确顺序展示

3. **转录进度展示**（用户层）：
   - 隐藏分段信息："被切成 4 段"（技术细节）
   - 展示百分比："已完成 67%"（用户关心）
   - 展示剩余时间："预计还需 2 分钟"（用户关心）

4. **转录失败处理**（用户层）：
   - 隐藏具体错误："segment_002 转录失败: FFmpeg error"（技术细节）
   - 展示友好提示："部分字幕转录失败，请重试"（用户理解）
   - 提供重试按钮：一键重试失败的部分

**用户体验验收标准**：
- [ ] 用户上传音频后，看到字幕依次加载（从上到下）
- [ ] 用户在任意字幕上划线，笔记显示在正确位置
- [ ] 用户关闭页面后再打开，笔记仍然按顺序展示
- [ ] 用户无法感知音频被切分或异步转录
- [ ] 转录进度显示直观（百分比 + 剩余时间），无技术术语

**开发者调试层**（仅供后台/日志）：
- 显示分段信息："总段数 4，已完成 2，失败 1，待处理 1"
- 显示详细错误："segment_002 转录失败: FFmpeg error: Invalid codec"
- 提供调试工具：查看每段的转录状态、重试次数

### 5.4.5 Highlight 简化设计（单 cue + 分组管理）⭐⭐⭐ 新增
**决策**：不允许单个 Highlight 跨 cue，改为自动拆分 + 分组管理  
**理由**：
- **核心问题**：如果允许 Highlight 跨 cue（start_cue_id + end_cue_id），异步转录时 cue 顺序变化会导致 Highlight 错乱
- **简化方案**：
  - 每个 Highlight 只关联一个 cue（cue_id）
  - 如果用户跨 cue 划线，前端自动拆分成多个 Highlight
  - 使用 `highlight_group_id`（UUID）关联同一次划线
  - 删除时按组删除，用户无感知
- **用户体验**：
  - 用户可以跨 cue 划线（自动拆分，用户看不到）
  - 笔记和划线按顺序展示
  - 完全符合 PRD 要求

**实现**：
```python
# Highlight 模型（简化！）
class Highlight(Base):
    cue_id = Column(Integer, ForeignKey("transcript_cues.id"))  # ⭐ 单 cue 关联
    start_offset = Column(Integer)
    end_offset = Column(Integer)
    highlighted_text = Column(Text)
    highlight_group_id = Column(String, nullable=True, index=True)  # ⭐ 分组 ID
    color = Column(String, default="#9C27B0")

# 前端划线逻辑
function handleTextSelection(selection) {
    const affectedCues = getAffectedCues(selection);
    
    if (affectedCues.length === 1) {
        // 单 cue 划线（90% 场景）
        createHighlight({
            cue_id: affectedCues[0].id,
            start_offset: selection.startOffset,
            end_offset: selection.endOffset,
            highlight_group_id: null
        });
    } else {
        // 跨 cue 划线（10% 场景）
        const groupId = generateUUID();
        affectedCues.forEach((cue, index) => {
            createHighlight({
                cue_id: cue.id,
                start_offset: index === 0 ? selection.startOffset : 0,
                end_offset: index === affectedCues.length - 1 ? selection.endOffset : cue.text.length,
                highlight_group_id: groupId  // ⭐ 同一组
            });
        });
    }
}

# 删除逻辑
def delete_highlight(highlight_id):
    highlight = db.query(Highlight).get(highlight_id)
    if highlight.highlight_group_id:
        # 按组删除
        db.query(Highlight).filter(
            Highlight.highlight_group_id == highlight.highlight_group_id
        ).delete()
    else:
        db.delete(highlight)
    db.commit()
```

**优点**：
- ✅ 极大简化设计：每个 Highlight 只关联一个 cue
- ✅ 完全解决 cue_index 变化问题：使用 `cue.id`（主键），永不变化
- ✅ 前端渲染简单：每个 cue 独立渲染高亮
- ✅ 符合 90% 的实际使用场景（单词/句子划线）
- ✅ 通过分组管理仍然支持跨 cue 划线（用户无感知）

### 5.4.5 转录状态双层设计（用户体验优化）⭐ 新增
**决策**：`transcription_status` 作为物理字段（用于高效查询），`progress` 等使用 `@property` 分层设计（用户层 + 调试层）  
**理由**：
- **用户体验优先**：隐藏技术细节（分段），只显示结果（进度、剩余时间）
- **关注点分离**：用户看简洁信息，开发者看详细数据
- **保证数据一致性**：Segment 状态为单一数据源
- **符合产品原则**："Don't Make Me Think" - 用户不需要知道"被切成几段"

**用户界面层**（隐藏技术细节）：
```python
episode.transcription_progress          # → 67.0（百分比）
episode.transcription_status_display    # → "正在转录中..."
episode.estimated_time_remaining        # → 90（秒）
```

**开发调试层**（完整技术数据）：
```python
episode.transcription_stats             # → {"total_segments": 4, "completed": 2, ...}
episode.failed_segments_detail          # → [{"segment_id": "002", "error": "..."}]
```

**前端展示示例**：
```javascript
// ✅ 用户看到
<LinearProgress value={episode.transcription_progress} />
<Typography>{episode.transcription_status_display}</Typography>
<Typography>预计还需 {formatTime(episode.estimated_time_remaining)}</Typography>

// 🔧 开发者调试页面看到
<DebugPanel stats={episode.transcription_stats} />
```

### 5.5 笔记类型（三种）
**决策**：`note_type` = `underline`/`thought`/`ai_query`  
**理由**：
- `underline`：纯划线（只有下划线样式，不显示笔记卡片）
- `thought`：用户想法（显示笔记卡片）
- `ai_query`：AI 查询结果（显示笔记卡片）
- 所有笔记都必须关联 `highlight_id`（划线操作）

### 5.6 划线数据结构
**决策**：保存 `start_offset` 和 `end_offset`（相对于 cue 的字符位置）  
**理由**：支持跨段落划线（未来扩展），避免存储重复文本

### 5.7 前端状态管理
**决策**：初期使用 React `useState` + Context，后期考虑 Zustand  
**理由**：快速开发，避免过度设计

### 5.8 AI API 选型
**决策**：
- 单词翻译：Google Translate API（免费）
- 短语解释：OpenAI GPT-3.5-turbo（低成本，约 $0.002/次）
- 专有名词：GPT-3.5-turbo + 上下文注入

**理由**：平衡成本和效果，避免高昂的 GPT-4 费用

### 5.9 数据库选型
**决策**：SQLite（本地文件数据库）  
**理由**：符合「Local-First」理念，无需额外部署数据库服务

### 5.10 测试策略
**决策**：TDD（测试驱动开发）  
**理由**：提前发现 Bug，保证代码质量，便于重构

---

## 附录：Definition of Done（完成标准）

每个任务完成后，必须满足以下标准：

- [ ] **测试通过**：所有单元测试和集成测试为绿色
- [ ] **UI 状态完整**：交互元素有 Normal、Hover、Active 三种状态
- [ ] **错误处理**：无 Silent Failure，用户看到友好提示
- [ ] **代码清理**：无 `console.log`、`print`、注释掉的代码
- [ ] **无硬编码**：魔法数字和 URL 提取到 `constants.py` 或 `config.js`
- [ ] **文档更新**：`docs/changelog.md` 已更新

---

## 结语

本开发计划遵循 **TDD + 迭代式开发 + 用户价值优先** 的原则，确保每个阶段都能产出可用的功能模块。

**下一步行动**：
1. 切换到 Agent 模式
2. 开始执行 **Task 1.1：数据库模型重构**
3. 祝开发顺利！🚀


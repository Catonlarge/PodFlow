1. 基本信息
修订日期
修订人
修订内容

Aug 05, 2025  Tuesday
明月
初稿

Aug 13, 2025  Wednesday
明月
1. 更改笔记区域收起图标；

Aug 14, 2025  Thursday
明月
1. 划线英文字幕弹出操作菜单栏
    a. 增加纯划线操作；
    b. 更改笔记数据结构，兼容纯划线操作；
2. 增加笔记划线源可点击的交互逻辑；
3. 修改笔记卡片展示样式，增加标题栏，增加编辑和删除按钮；增加对应交互；

Aug 15, 2025  Friday
明月
1. 更改项目产品名称为PodFlow；
2. 补充AI查询卡片后端的逻辑；先调试一下接口的效果尤其是要注意一下数据格式；

Oct 17, 2025  Friday
明月
为了可用性增加以下两个场景：
1. 音频和字幕导入

Oct 30, 2025  Thursday
明月
对接上字幕识别接口；
对接上异步识别字幕和加载字幕的逻辑

2. 产品概述
• 产品名称：PodFlow
• 版本号：v1
3. 产品目标
• 背景与问题陈述（市场/用户痛点）  
    ◦ 海外播客市场发展非常成熟，技术大牛是经常上播客的，沉淀下来了非常多的英文播客
    ◦ 对于中国的学习者来说，优质的英文播客无法学习，因为听不懂，词汇太复杂了，时间太长了，直接听是非常懵逼的；
    ◦ 而且听完了是无法做笔记吸收的；
• 产品愿景与核心价值  
    ◦ 打破信息差，让用户可以把优质的英文播客可以当成一种很成熟的海外课程来吸收消化；
    ◦ 规避版权问题：如何利用AI学习任何一门英文播客；
4. 目标用户与场景
• 角色：对学习有要求，但是英文水平只是适中的人，跨行业进行学习的人；他们的学历水平偏高，善于自学；有晋升、转行需求，对知识吸收要求非常密集，对价格不敏感
    ◦ 年龄：25-40岁，面临一定的职场/学业压力，面临转型危机
    ◦ 职业：互联网、科技相关
    ◦ 收入：较高
    ◦ 学历：本科及以上
• 行为特征
    ◦ 听播客频率：每周 4-5 次，每次 20-40 分钟
    ◦ 收听场景：通勤（地铁 / 公交，占 60%）、午休时（20%）、睡前（20%）
    ◦ 偏好内容：AI科技资讯
    ◦ 操作习惯：通过手机 App 收听，会主动搜索关键词（如 “职场新人”），但也依赖平台推荐；很少留言互动，偶尔会收藏感兴趣的单集。
• 需求与痛点
    ◦ 核心需求：获取优质英文播客知识，提升职场竞争力，避免 “信息焦虑”。
    ◦ 注意这里优质英文信息吸收是核心；英文学习是服务于优质英文吸收的；
    ◦ 痛点：
        ▪ 优质的英文播客无法学习，因为听不懂，词汇太复杂了，时间太长了，直接听是非常懵逼的；
        ▪ 听完了播客无法做笔记吸收；
        ▪ 没有系统性学习的时间；
5. 需求范围
💡核心功能列表（按优先级排序）：
最最核心的功能是什么？是音频与英文字幕对照，以及英文字幕与笔记对照，音频、英文字幕和笔记都可以增删改查；
1. 平台优先级：基础版本windows PC端>ipad端>手机端IOS>手机端ipad
2. 播客导入：最好的用户提供链接导入
3. 听播客：
    a. 英文播客对照字幕+对照字幕随着音频实时滚动
    b. 对于英文字幕：
        i. 可以进行划线操作，划线内容可以是单词、句子或者段落
        ii. 对于划线内容可以进行的操作是：AI查询、划线和记录想法
        iii. 所有AI查询结果可以一键添加到笔记，AI查询是带有上下文的查询，针对专有名词需要在专有名词领域进行翻译
        iv. 记录的想法直接形成笔记
    c. 屏幕分为左右两栏，笔记默认展示在逐字稿右侧，笔记跟随在划线源右侧同等高度，并且“始终跟随划线源”；
    d. 笔记和划线源形成双向链接展示，便于对照查看；
4. 笔记管理：
    a. 特别基础的必须要包括以下几点：
        i. 可以划线增、删、改自己的笔记；
5. 音频自动生成字幕：异步逻辑
6. AI翻译单词：？用免费的api？


7. 高级功能（以后再说）：
    a. 英文播客总结：
        i. 英文播客生成总结+思维导图
        ii. 英文播客自动分段分章节生产总结+思维导图
        iii. 导出英文字幕文件和对应的总结
    b. 笔记高级管理功能：
        i. 可以搜索自己的笔记；
        ii. 导出笔记；
    c. 笔记内容的关联：
        i. 笔记内容的自动化整理，标签体系
        ii. 笔记关联整理；
    d. 传播功能：
        i. 分享卡片；
    e. 非功能需求：
        i. 兼容性；
        ii. 笔记需要可以跨端浏览；
        iii. 性能；
        iv. 安全性；
6. 功能详细描述

6.1. 界面1：上传音频文件并且识别字幕界面
6.1.1. 用户选择上传文件
    a. 音频和字幕选择按钮（先这样，后面增加异步的字幕识别逻辑，已经生产的字幕本身就要有cache的逻辑）
            (1) 位置：音频控制面板“音量调节条”右侧，图标和已有的音频控制图标风格保持一致，视觉大小保持一致，图标上无需文字
        i. 元素：音频和字幕选择按钮
        ii. 交互：
            (1) 增点击这个“音频和字幕选择按钮”按钮弹出“音频和字幕选择弹框”；
            (2) 如果在没有选择任何音频文件的情况下，点击其他部分，这个弹框不消失并且闪烁一下，要求用户选择音频文件；除非用户主动点击弹窗的关闭按钮；
    b. 音频和字幕选择弹框
        i. 位置：
            (1) 弹框屏幕居中，并且悬浮在最上层；如果在没有选择任何音频文件的情况下，点击其他部分，这个弹框不消失并且闪烁一下，要求用户选择音频文件；除非用户主动点击弹窗的关闭按钮；
        ii. 元素：
            (1) 弹框分为标题栏和选择器
            (2) 标题栏在顶端：名字“音频和字幕选择弹框”，右侧有关闭按钮
            (3) 选择器：
                ① 在标题栏下方；
                ② 选择音频文件路径填空条：在标题栏下面；名字“选择音频”，白色路径填空条在名字右边，点击呼唤起系统文件选择器，这样用户可以自己选择本地任意路径的文件；支持的文件格式包括：mp3、WAV；支持格式以灰色文字默认显示在白色路径填空条里面；
                ③ 字幕识别勾选框：在音频文件路径填空条下面；如果用户勾选这个选项，则“字幕文件路径填空条”置灰，这个勾选之后，“字幕文件路径填空条”失效，即使传参也不走加载逻辑；
                    1) 目前先加上这个字幕识别勾选框占位，不用实际实现，后续补充这里代码
                ④ 选择字幕文件路径填空条：在字幕文件路径填空条下面；名字“选择字幕”，白色路径填空条在名字右边，点击呼唤起系统文件选择器，这样用户可以自己选择本地任意路径的文件；支持的文件格式仅json；支持格式以灰色文字默认显示在白色路径填空条里面；
                    1) 如果在用户选择的“音频文件路径下”存在“对应字幕文件”，则自动填充“字幕文件路径”；
                    2) 如果在如果在用户选择的“音频文件路径下”不存在“对应字幕文件”，则由用户自己选择“字幕文件路径”；
                    3) “音频文件”和“对应字幕文件”由储存在本地的关联关系数据判定；
                ⑤ 在通过“音频和字幕选择弹框”重新选择音频和字幕之后，播客学习界面的音频和字幕重新加载，跟随这个音频和字幕的笔记卡片也需要加载出来；
                ⑥ 用户的字幕文件的metadata无法读取时/识别字幕文件的metadata无法读取时，按照下列规则填充metadata信息：
                    1)  "episodeTitle"：用户的音频文件名字
                    2) "language": "en-US"
                    3) "transcribedAt": 真实时间
                    4) "showName": "本地音频"
"metadata": {
    "episodeTitle": "Anthropic co-founder AGI predictions, leaving OpenAI, what keeps him up at night  Ben Mann",
    "audioFileName": "202508091059-mini.mp3",
    "language": "en-US",
    "transcribedAt": "2025-08-09T18:36:26Z",
    "showName": "Lenny's Podcast"
  }            (4) 首次：如果用户第一次打开界面，没有选择过任何音频文件和字幕文件，自动弹出“音频和字幕选择弹框”；
                ① 如果此时用户关闭这个弹框则字幕识别区域居中显示“您还未选择音频文件，点击按钮进行选择”；在这个提示右侧出现“音频和字幕选择按钮”这个按钮点击之后的逻辑还是弹出已有的“音频和字幕选择弹框”；相当于在未加载任何音频的时候，“音频和字幕选择弹框”多了一个入口；
            (5) 已经用过：在用户已经选择一次“音频和字幕文件”过后/或者是选择过音频并且勾选过识别字幕之后，后面用户再打开播客学习界面，保持展示用户上次选择/识别的“音频”和“字幕”；不再主动弹出“音频和字幕选择弹框”；
            (6) 在用户主动打开“音频和字幕选择弹框”，并且重复选择了音频文件，如果一个音频文件已经被识别过字幕，那么在“字幕文件路径下”直接填充对应的“识别字幕segment001”，用户点击确认之后，加载对应音频和字幕，并且随着用户的滚动界面异步加载完整字幕
        iii. 用户上传文件选择限制：
            (1) 音频文件不得超过X个小时；大小不得超过Y个G；
            (2) 如果音频文件超过X小时/大小超过Y个G；弹框提示用户“选择音频文件不得超过X个小时；大小不得超过Y个G；”
            (3) 现在X=3，Y=1；
        iv. 错误处理：
            (1) 在音频和字幕文件选择弹框弹出之后，用户选择音频文件002（已经被识别过），字幕文件路径被自动加载，但是用户此时再切换音频文件004（已被识别过），字幕文件路径不会被重新检查并且填充，导致音频和字幕对应错位打开并且这种关系被记录，正确表现应该为：用户在弹框里切换音频，如果音频的字幕文件存在，应该随着音频的切换而自动切换
6.1.2. 音频处理逻辑和loading界面：
Oct 20, 2025  Monday
管理逻辑：这里其实是增、删、改、查逻辑，但是这里现在缺少删、改、查逻辑
信息提示逻辑：开始、等待、错误、结束提示
各种按钮的联动逻辑：先后关系、必选/可选逻辑
    a. 在“音频和字幕选择弹框”中选择了音频和字幕，音频文件上传到本地服务器：
        i. 音频上传完成之前，不加载字幕文件；
        ii. 上传过程中：
            (1) “音频和字幕选择弹框”消失，回到“播客学习界面”；
            (2) 在英文字幕区域中间显示提示“请稍等，音频上传中”，在这句提示下方显示“音频上传进度条”；
            (3) 字幕识别进度条计算方式：如果音频文件时长为X，上传速度为0.1X，字幕进度条按照识别为匀速进行显示进度；音频上传完成之后，进度条直接走到100%；
        iii. 上传失败：
            (1) 在英文字幕区域中间显示提示“上传失败，错误原因：{填充识别失败抛出的exception message}，请重试”
            (2) 在这句提示的右侧显示一个重试图标“一个转圈箭头”，图标风格和大小和界面已有图标保持一致，图标上面没有文字；
            (3) 点击这个重试图标，重新上传音频；
        iv. 上传完成：
            (1) 上传成功后，把音频文件正常加载到“播客学习界面”，即为显示好“播客源数据”并且音频控制面板可以实际控制这个音频；
            (2) 上传完成后，在英文字幕区域直接加载识别出来的字幕；
            (3) 字幕加载过程中：在英文字幕区域中间显示提示“请稍等，字幕加载中”，在这句提示下方显示“字幕加载进度条”；
            (4) 如果字幕加载失败，则在英文字幕区域中间显示提示“字幕加载失败，错误原因：{填充识别失败抛出的exception message}，请重试”在这句提示的右侧显示一个重试图标“一个转圈箭头”，图标风格和大小和界面已有图标保持一致，图标上面没有文字；
            (5) 点击这个重试图标，仅仅重新加载字幕；不需要重新加载音频；
🔔重新叙述一下这里的逻辑：
音频上传成功->加载字幕->加载字幕可能成功或者失败，成功或者失败后对应字幕的加载显示和字幕加载重试逻辑，跟前面已经上传的音频无关
音频上传失败->出现音频重试提示->点击重新上传音频，此时字幕不加载，字幕只有在音频上传成功之后再加载
    b. 在“音频和字幕选择弹框”中选择了音频文件，并且勾选了“字幕识别勾选框”，并且点击了确认；
        i. 关联逻辑：如果勾选了“字幕识别勾选框”，但是没有选择音频文件，点击确认，此时弹框提示“请选择需要识别字幕的音频文件”；也就是说，选择“字幕识别”功能，必须要在选择了“音频文件”以后才能够生效；
        ii. 在“音频和字幕选择弹框”中选择了音频文件，并且勾选了“字幕识别勾选框”，并且点击了确认，“音频和字幕选择弹框”消失，回到“播客学习界面”；
        iii. 音频上传完成后，把音频文件正常加载到“播客学习界面”，即为显示“播客源数据”并且音频控制面板可以实际控制这个音频；
        iv. 如果音频加载完，字幕文件已经生成了，则加载字幕到“播客学习界面”；
        v. 音频加载完，如果字幕文件还没有识别出来则按照下面规则显示元素和交互（放在后面再说详细的规则）；
    c. 字幕识别过程中：注意这个过程是字幕识别->字幕加载，识别和加载是两回事
        i. 字幕识别过程中：
            (1) 在英文字幕区域中间显示提示“请稍等，努力识别字幕中”，在这句提示下方显示“字幕识别进度条”；
            (2) 字幕识别进度条计算方式：如果音频文件时长为X，那么总的识别时间为0.4X，字幕进度条按照识别为匀速进行显示进度；字幕识别的文字提示保留两位小数；
            (3) 在字幕识别进度条右侧，有一个“字幕识别控制按钮”，默认字幕在识别过程中，展示“方形”，点击一下，字幕识别被取消，这个按钮变成“三角形”；再次点击一下，字幕识别重新开始，这个按钮变成“方形”；这个控制逻辑跟音频的播放和暂停很像；
        ii. 字幕识别失败：继续实现下面的逻辑，记得添加逻辑让我可以测试字幕识别失败的情况
            (1) 在英文字幕区域中间显示提示“识别失败，错误原因：{填充识别失败抛出的exception message}，请重试”
            (2) 在这句提示的右侧显示一个重试图标“一个转圈箭头”，图标风格和大小和界面已有图标保持一致，图标上面没有文字；
            (3) 点击这个重试图标，重新调用API进行字幕识别和说话人识别（现在先不实现只是占位一下）；
        iii. 识别完成：
            (1) 在英文字幕区域直接加载识别出来的字幕；
    d. 用户上传音频后字幕识别逻辑：这是后台逻辑，注意添加调试语句，以及需要告诉我如何在控制台查看和测试效果
        i. 你需要设计程序里面储存数据的格式、结构和逻辑
        ii. 用户上传音频小于3min：
            (1) 直接调用API进行字幕识别和说话人识别（现在先不实现只是占位一下）；
            (2) 识别成功后直接加载字幕；其他关于识别过程、失败等逻辑不变；
        iii. 用户上传音频大于3min：
            (1) 把用户音频文件以3min为单位，调用脚本在服务器内把音频切割为不同的segment；注意每段segment的命名必须体现出来他们的先后顺序（脚本现在还没写，先占位一下；）；切分segment是为了进行异步字幕识别，分段识别并且加载和渲染字幕，不然用户等待太久；
            (2) segment的数据结构：segment的信息必须包含以下几条，设计数据结构，并且记录在数据结构文档里面；考虑好segment和音频、episode的映射关系；
                ① segment本身
                ② segment之间的顺序关系
                ③ segmen来源的音频文件和episode；
                ④ 记录开始和结束的segment；
                ⑤ 用户多次上传同一个音频文件，需要去重
            (3) 重复文件逻辑：记得用户可能要多次上传同一个音频文件，也可能会多次识别同一个音频文件的字幕，需要做去重的逻辑
                ① （用户多次选择同一个音频文件上传，这个音频文件会被切割多次并且储存多次，正确表现应该为检测为已经处理过的音频，就保留一次上传和切割结果即可）
                ② 检测到重复文件，音频和字幕选择弹框用户可以点击“确认选择”，点击之后音频和字幕选择弹框消失，之后直接加载已经存在的音频和字幕文件即可，不要卡住用户的操作
                ③ 字幕识别过程中，显示字幕识别的提示；字幕识别完成后，加载字幕；遇到重复文件，用户点击确认之后，直接加载已有的音频和字幕文件，不需要重新经历字幕识别过程
            (4) 切割完成之后，每段segment按照次序开始调用API进行字幕识别和说话人识别（现在先不实现只是占位一下）；
            (5) 第1个segment的字幕被识别完成之后，直接加载在屏幕上，让用户可以开始正常播放音频；后续在用户播放过程中继续识别后面的segment；此时是静默识别，不需要在屏幕中间显示字幕识别提示；
            (6) 如果用户往下滚动“播客学习界面”，滚动到已经识别字幕的底端：
                ① 如果下一个segment已经识别完了，则加载到屏幕上；
                ② 如果下1个segment在识别过程中，则在屏幕底部居中显示一行字“……请稍等，努力识别字幕中……”；注意这个时候不要调用以前已有的字幕识别提示，仅仅在底部显示一句话即可；
                ③ 此过程直到本音频的segment全被字幕识别完毕；用户滚动到已经识别字幕的底端，在底部用灰色小字居中显示“-END-”
            (7) 如果某个segment的字幕识别失败，自动重新调用字幕识别接口重试，如果重试3次仍然不成功，则停止识别，弹框提示用户“字幕识别失败，请稍后重试，或者切换音频文件”
            (8) 已经识别成功的字幕需要储存下来，下次用户加载对应的音频文件的时候，如果检查到已有的字幕文件，自动加载“音频和字幕选择弹框”的字幕文件路径填空条里面；“音频文件”和“对应字幕文件”由储存在数据库的关联关系数据判定；
            (9) 用户多次滚动屏幕，已经加载的字幕会被反复不断的加载，看下这个逻辑需要怎么优化
            (10) 异步过程中失败：
                ① 在用户选择了音频004之后，音频被分段了，但是分段之后，第二个分段的字幕识别失败了，此时用户退出了播客学习界面，下次再打开播客学习界面之后，音频004和对应字幕segment001被加载了，但是此时用户滚动界面之后，segment002不存在因为识别失败了，就加载不出来了，正确表现应该为：继续识别segment002的字幕，并且如果下1个segment在识别过程中，则在屏幕底部居中显示一行字“……请稍等，努力识别字幕中……”；注意这个时候不要调用以前已有的字幕识别提示，仅仅在底部显示一句话即可；
                ② 如果用户在segment002还在识别的过程中，直接滚动到segment001底部，此时会触发segment002异步加载逻辑，但是正确表现应该为，确认segment002还没有被识别完成，就不再尝试异步加载字幕，优化这个逻辑；
                ③ 如果音频切割为segment001和segment002之后，用户在segment002识别过程中关闭服务器，那么关于这段音频实际被切割为2段的信息会丢失，因此下次打开播客学习界面，segment002的字幕识别不会被自动触发，正确表现应该为：确认音频有X段，有Y段未识别完成，下次打开这个音频时，自动开始识别未识别完成的Y段，并且跟随用户的鼠标滚动异步加载渲染到屏幕上
            (11) 现在在识别的字幕文件上，使用AI查询，并且增加笔记卡片，下次再打开播客学习界面，打开同一个音频文件，笔记卡片会丢失，正确表现应该为笔记卡片不会丢失；相当于已经被识别的字幕文件和音频文件和笔记卡片是已经建立了关联储存在数据库中的，检查现在数据库的结构和关联方式，修复这个bug

6.1.3. 实现字幕识别
检查本地已有的whisperX代码，这是本地的字幕识别接口；
真实实现whisperX接口去进行异步的字幕识别；


6.2. 界面1：英文播客学习界面
6.2.1. 总原则和界面模块
1. 原则：沉浸式学习，聚焦于展示英文字幕，对于英文字幕的划线处理，以及划线部分对应的笔记，不要用其他信息打扰用户。
2. 总界面描述：
    a. 播客学习界面分为三个部分播客episode信息界面、音频操作界面和英文字幕区域（主体区域）；其中播客episode信息界面、音频操作界面两个部分画面占比较小：英文字幕区域需要占比屏幕90%。
    b. 播客episode信息界面在顶端、下面是英文字幕区域（因为英文字幕区域为左右分栏，左边显示英文字幕，右边显示笔记卡片）、音频操作界面（底部悬浮条，左边音频进度条，右边控制按钮）。
    c. 先做一个骨架图出来，不需要有任何交互逻辑存在。
6.2.2. 播客源数据展示模块
    a. 播客episode信息界面：
        i. 位置：屏幕顶层矩形区域
        ii. 元素：
            (1) 基础信息：靠左展示播客episode的名称、episode归属show/channel的名称
            (2) 传播（以后再考虑）：分享、收藏按钮
        iii. 交互（以后再说）：
6.2.3. 音频控制模块
    a. 音频播放进度条：
        i. 位置：悬浮条组件，始终位于屏幕最下方靠左，随着鼠标滚动屏幕，这个组件始终展示在固定的屏幕最下方。
        ii. 元素：
            (1) 已播放时间：最左侧显示已播放时间，如“-1:13:00”，表示已经播放了“1小时，13分钟，00秒”，如果播放时间不足1个小时，则格式为“-13:00”，表示已经播放了“13分钟00秒”；
            (2) 音频播放进度条：在“已播放时间”和“音频总时长”中间
            (3) 音频总时长：最右侧显示音频总时长，如“1:42:00”，表示音频总时长为“1小时，42分钟，00秒”，如果播放时间不足1个小时，则格式为“55:00”，表示音频总时长为“55分钟00秒”；
        iii. 交互点：
            (1) 音频播放进度条可以拖拽；
            (2) 已播放时间随着音频进度实时变动；
    b. 音频控制面板：
        i. 位置：
            (1) 悬浮条组件，随着鼠标滚动屏幕，这个组件始终展示在固定的屏幕最下方。
            (2) 跟“音频播放进度条”在同一水平线上。
            (3) 水平位置在“音频进度条-音频总时长”右侧24px处。
        ii. 元素：从左往右分别为
            (1) 后退15s按钮
            (2) 播放/暂停按钮
            (3) 前进30s按钮
            (4) 播放速度调节按钮
            (5) 音量调节条
        iii. 交互点：
            (1) 后退15s按钮：点击按钮音频后退15s，音频进度条同时也后退15s
            (2) 播放/暂停按钮：默认状态：此按钮显示“暂停”图案，音频为播放状态，音频进度条随着播放进度变化，点击这个按钮之后，音频暂停播放，按钮图案变为“播放”图案；当按钮显示“播放图案”时，点击这个按钮，音频开始播放，按钮图案变为“暂停”图案。
            (3) 前进30s按钮：音频前进30s，音频进度条同时也前进30s
            (4) 播放速度调节按钮：直接显示播放速度，默认显示"1X（此时音频的播放速度为音频原速）"，点击依次变成"1.25X（此时音频的播放速度为音频原速的1.25倍）"、"1.5X（此时音频的播放速度为音频原速的1.5倍）"、"0.75X（此时音频的播放速度为音频原速的0.75倍）"、"1X（此时音频的播放速度为音频原速）"，因为只有4个选择，所以点击"1.5X"后循环回到"0.75X"->"1X"->"1.25X"->"1.5X"->"0.75X"；
            (5) 音量调节条：音量调节条前面是一个喇叭图案/静音图案，默认为喇叭图案，此时音频是依据音频调节条的音量在播放；点击“喇叭图案”则音频变为静音状态，按钮图案切换为静音图案；音量调节条可以拖动调节音量，音频的播放音量由这个音量调节条控制；
            (6) 快捷键：用户“空格键”可以暂停/继续播放当前音频
    c. 音频播放进度条与音频控制面板展示逻辑：
        i. 展示逻辑：
            (1) 在打开页面的时候默认在屏幕下方展示；
            (2) 如果在5s内用户没有任何在“音频播放进度条和音频控制面板”上的有任何的交互动作（如点击任何按钮、拖动任何进度条），则“音频播放进度条和音频控制面板”向下收缩成一条“5px”的矩形，我们把它命名为“收缩音频面板”；
            (3) “收缩音频面板”仍然以有颜色的进度条的形式展示音频播放的进度，举个例子：音频播放20%，则“收缩音频面板”的前20%长度被着色为紫色；
        ii. 交互点：
            (1) 用户鼠标点击“收缩音频面板”则，收缩音频面板网上弹起，回到“音频播放进度条和音频控制面板”的形式；
            (2) 如果用户再次在5s内没有任何在“音频播放进度条和音频控制面板”上的有任何的交互动作（如点击任何按钮、拖动任何进度条），则“音频播放进度条和音频控制面板”向下收缩成回到“收缩音频面板”；
6.2.4. 英文字幕区域与笔记区域
    a. 基础展示逻辑：
        i. 位置：在音频控制面板下方
        ii. 元素：
            (1) 左右分栏：左边为英文字幕区域，显示音频对照英文字幕；右侧为笔记区域，显示笔记；
            (2) 英文字幕区域：
                ① 位置：播客episode信息界面下方区域左右分栏，英文字幕区域在左边分栏；
                ② 结构：只有一个内容容器；
                ③ 元素：
                ◦ 英文字幕分段逻辑（分段逻辑后面直接加在字幕识别上面吧，别放在字幕样式展示哪里）：
                    ▪ 英文字幕的speaker标签：单独占据一行，展示在每个speaker开始说的第一句话的上面一行；英文字幕speaker标签单独占据的一行，没有时间标签，与下一行的行距与英文字幕句子之间的行距保持一致。按照在<>中的格式修改
<Speaker1：
00:00 Welcome to The Tim Ferriss Show, I'm your host Tim Ferriss.
00:05 Today we're going to talk about how to learn anything faster.
Speaker2：
00:12 Hello，everyone！
00:14 I am Mia. I am very honored to be here to talk to Tim.>                ◦ 识别出英文播客音频中每一句话，单独成为一个段落，也就是下一句话需要另起一个段落。字体大小15px，左右缩进8px，段后距24px。英文字幕随屏幕大小自动换行，自动换行之后的行距也是2。（优化代码结构：字幕样式变成统一的样式控制，也就是一个样式控制可以调节所有字幕效果）
                ◦ 英文字幕区域时间标签：每一条英文字幕的时间标签，放在对应英文字幕的左侧，始终跟英文字幕本身顶端对齐；英文字幕开始于时间标签右侧10px位置。时间标签字体样式（包括大小、颜色等）跟英文字幕字体样式保持一致。
                ◦ 英文字幕区域“显示翻译”按钮：在“英文字幕区域”顶端靠右的位置，有一个“显示翻译”按钮，默认为不选中的状态（即为按钮置灰状态），此时“英文字幕区域”只显示对应音频的识别字幕，不显示对应的中文翻译；点击“显示翻译”按钮，按钮变成选择状态（按钮非置灰状态），此时不仅显示对应音频的识别字幕，还要在对应识别字幕的下方显示这句话的中文翻译，中文翻译和英文字幕之间左对齐，行距为8px，如果中文翻译超过1行，需要自动换行。
                ④ 英文字幕动效逻辑：
                ◦ 未播放句子和已经播放过的句子矩形背景为白色无边框，且词汇保持一致的灰色。每句英文字幕的位置在白色无边框矩形背景垂直居中的位置，内容在白色无边框矩形背景中左对齐。
                ◦ 随着音频播放，播放到的“那句”英文字幕对应的“矩形背景”变成选中态（每句英文字幕的矩形背景的选中态，边框修改为紫色，跟音频播放进度条的色系保持一致）；播放过这句话，矩形背景变回原来的颜色。
                ◦ 播放的那一句话中，已经播放的词汇保持加深颜色，未播放的词汇保持灰色。
                ◦ 如果用户在界面上没有进行任何操作，如点击、滚动等等，当高亮字幕在用户不可见区域时，自动滚动，让高亮字幕保持在屏幕上1/3处；如果用户使用滚轮操作屏幕，则停止滚动，用户鼠标没有动作之后5s，重新回到滚动状态。
                ◦ 滚动逻辑与划线和AI查询操作之间的逻辑：修改英文字幕区域的滚动逻辑：如果用户在页面上进行划线操作、“查询和想法操作弹框”展示或者是“AI查询卡片”在展示的时候，即使高亮字幕已经在用户不可见区域，高亮字幕也不自动滚动。需要等待“AI查询卡片”消失或者是用户没有进行鼠标划线、点击操作的5s之后，再恢复英文高亮字幕在用户不可见区域会自动滚动到屏幕上1/3处的逻辑。
            (3) 英文字幕与音频的交互点：
                ① 单击每一段英文字幕，音频会从那段字幕开始的地方进行播放。
                ② 单击每一段英文字幕容器
                ③ 调整音频播放进度条，会自动对应到字幕上；
    b. 划线操作：
        i. 划线操作是指：当用户在英文字幕区域，按住鼠标左键对英文字幕进行滑动选择；
        ii. 用户划线内容可以是单词、句子或者段落；禁止重叠划线；
        iii. 滑动选择之后出现“操作弹框”，修改操作弹框，增加一个“纯划线”按钮，依次出现三个操作按钮为“纯划线”、“查询”和“想法”；
            (1) 样式：三个操作按钮都用图标展示，不需要文字，下划线图标=“纯划线” 、放大镜=查询、灯泡=想法，灰色矢量，无背景。按钮 hover/点击展示浅灰色背景。
            (2) 位置：“操作弹框”始终在用户“划线源”附近；
            (3) 如果屏幕够用，则操作弹框默认在“划线源”正上方10px处悬浮展示；
            (4) 如果屏幕不够用：屏幕上方不够用，则操作弹框在“划线源”正下方10px处悬浮展示；屏幕左边不够用，则操作弹框在“划线源”正上方10px处，水平往右挪动到可以完整展示的位置；屏幕右边不够用，则操作弹框在“划线源”正上方10px处，水平往左挪动到可以完整展示的位置；
            (5) 交互：
            • 用户点击“AI查询”或者“记录想法”任一按钮并且生成笔记之后，划线生效；被划线的字幕出现紫色下划线；
            • 用户如果不点击“纯划线”、“AI查询”或者“记录想法”且生成笔记数据则划线效果不生效；“操作弹框”消失；
    c. 已生成笔记划线源交互：
            • 如果下划线样式生效（也就证明用户在滑动选择之后创建了笔记数据），那么对应的划线源变为可点击的容器。这里的交互是：用户在hover到划线源时，划线源的背景会变成稍微加深的灰色，用户可以单击划线源。
            • 用户单击已经生成笔记数据的划线源容器：
                ◦ 判断笔记类别，也就是笔记json数据中的"type"类型：
                ◦ 如果笔记类型是underline，则单击划线源容器，在划线源容器附近弹出一个垃圾桶图标，垃圾桶图标与本界面其他图标视觉效果保持一致。单击垃圾桶图标先不绑定任何交互逻辑。做成界面效果以供查看。垃圾桶图标弹框位置计算逻辑跟用户鼠标滑动选择弹出的“操作弹框”位置计算逻辑一致。
                ◦ 点击垃圾桶图标，
                ◦ 则划线源的笔记数据被删除，注意这个删除包括：笔记卡片、下划线效果、本地json数据；
                ◦ 如果笔记类型不是underline，则：
                    ▪ 判断右侧笔记区域是否展开：
                        • 如果展开：则单击划线源容器，划线源对应的笔记卡片闪烁一下，并且冒泡到笔记卡片的最前面。也就是说如果同一个位置有多个笔记卡片重叠，单击单击划线源容器会使得对应笔记卡片展示在最前面。
                        • 如果不展开：则单击划线源容器，笔记区域先展开，然后划线源对应的笔记卡片闪烁一下，并且冒泡到笔记卡片的最前面。也就是说如果同一个位置有多个笔记卡片重叠，单击单击划线源容器会使得对应笔记卡片展示在最前面。
    d. 用户点击“纯划线”（Aug 14, 2025  Thursday）：
            (1) 交互：
                ① 生效：当用户点击纯划线图标，“操作弹框”消失；用户“按住鼠标左键对英文字幕进行滑动选择”的部分，下划线样式生效；同时产生一个“下划线笔记”。
                ② 删除（等会儿再说）：用户双击下划线笔记，弹出一个垃圾桶按钮，点击可以删除下划线笔记，记住这个删除是把json文件里面的数据和页面上展示的下划线样式都删除。
            (2) 数据：
                ① “下划线笔记数据”会增加到本地json文件中，这个数据与已经有的note.json数据格式兼容，只是增加了“下划线笔记”这一个笔记来源，下划线笔记的content就是用户鼠标滑动选择的那些内容；其他数据属性不变，帮我修改对应数据逻辑；
                ② “下划线笔记”是一种特殊的笔记，如果判定一个笔记为下划线笔记，它不会以笔记卡片的形式展现在笔记区域，它只会使得下划线样式生效，并且把数据存在本地json中。
                ③ 如果用户已经有下划线笔记，则下次打卡对应的播客学习界面时，“下划线笔记”使得对应划线源的下划线“样式”生效。（也就是下划线样式不会随着页面刷新/重启丢失），除非本地json文件里面下划线笔记的数据被删除了。
    e. 用户点击“查询”：
    ◦ AI查询卡片交互逻辑以及样式
        i. 用户点击“查询”，“操作弹框”消失，出现“AI查询卡片”：
        ii. “AI查询卡片”展示的文字内容是流式输出，现阶段先使用<>中的mock数据来展示卡片的效果；需要模拟出流式输出的效果；
<释义： 
发音：/tækˈsɒnəmi/ 
n. 分类学；分类法；分类系统 
解释： 
1. 在生物学中，taxonomy 指对生物体进行分类的科学，包括根据物种、属、科、目、纲、门、界等层级进行系统的分类和命名。例如，植物和动物的分类体系就是由 taxonomy 构建的。 
2. 在更广泛的领域中，taxonomy 也可以指任何事物的分类系统或方法，例如在信息科学中用于对数据、文档或知识进行分类的结构化方法。 
3. 在商业和管理领域，taxonomy 可能用于描述产品、服务或流程的分类体系，以便于组织和检索。 
4. 在机器学习和人工智能领域，taxonomy 可以用来构建标签体系或类别体系，用于训练模型或进行数据标注。>        iii. 卡片内容样式：
        iv. 卡片容器样式：
        ▪ 长宽以及生长规则：“AI查询卡片”是固定的宽度420px，内容流式输出从少变多的时候，高度从最小高度40px逐渐向下或者向上增长，能够增长到的“最大高度”为用户屏幕的一半；如果需要展示的内容高度超过用户屏幕的一半，则出现垂直方向的滚动条，允许用户上下滚动来浏览卡片内容。
        ▪ 卡片结构为：标题栏、内容区域
        ▪ 实现固定标题栏：标题栏始终固定在卡片顶部，即使内容区域滚动也保持可见，提升操作便利性。
            • 标题栏靠左：显示“AI查询图标”和标题“AI查询”；内容流式输出的时候，AI查询图标选择loading转圈图标，内容流式输出完成时，标题栏AI查询图标换成完成打勾图标，白色打勾，绿色背景
            • 标题栏靠右：笔记图标在标题栏的右侧；
            • 交互：
                ◦ 点击“笔记图标”之后，这条“AI查询卡片”的“内容”会形成一张“笔记卡片”（现阶段先用一个白色的卡片框来模拟）；同时“AI查询卡片”消失；
                ◦ 用户点击“笔记图标”之后，用户划线的“划线源”需要产生下划线的样式（把这个状态命名为“划线态”），注意如果用户不点击笔记图标，下划线样式并不会生效。下划线颜色默认跟划线源字体颜色保持一致（现在颜色是橙色）。
        v. “AI查询卡片”容器运动规则：同样悬浮在划线源附近；
        vi. 卡片垂直方向运动规则：
            (1) 如果划线位置在屏幕的上1/2处，则“AI查询卡片”默认在“划线源”下方10px处悬浮展示；卡片的增长方向为自上往下增长，当内容太多导致卡片下边缘贴在屏幕下边缘时，卡片顶部向上移动到能够展示出卡片内容为止。
                ① 如果划线位置在屏幕的下1/2处，则“AI查询卡片”默认在“划线源”上方10px处悬浮展示；卡片的增长方向为自下往上增长，当内容太多导致卡片上边缘贴在屏幕上边缘时，卡片顶部向下移动到能够展示出卡片内容为止。
        vii. 卡片水平方向运动规则：
            (1) 卡片的固定宽度为420px，默认在水平方向上与划线源中心对齐，如果此时，420px的卡片左右不会超出屏幕，则卡片的水平位置就是与划线源中心对齐的那个位置；
            (2) 卡片的固定宽度为420px，如果卡片在水平方向上与划线源中心对齐时，左边或者右边明显超出屏幕，则把卡片的水平展示位置挪到可以完整展示420px的宽度为止；
        viii. 卡片退出逻辑：
            (1) 在“AI查询卡片”展示时，如果用户此时点击卡片外的屏幕任何地方，卡片消失；卡片发送的请求被中断（等到加了接口之后再改）；
            (2) 在“AI查询卡片”展示时，如果用户滚动屏幕把“划线源”滚动到屏幕之外，则卡片消失；
    ◦ AI查询卡片的后端逻辑以及数据格式：
    f. 用户点击“想法”（以后再说先占位）：
    6.2.4.1. 用户修复字幕识别的错误（以后再说，先占位）

    g. 笔记区域（Aug 13, 2025  Wednesday）：
        i. 元素：
            • 笔记区域收缩悬浮按钮：
                ◦ 位置：把笔记收缩按钮样式改为向右箭头矢量图标（长9px高16px），用箭头本身代表收缩的意思，箭头的底边紧贴英文字幕区域和笔记区域分界线，尖端方向朝向笔记区域；
                ◦ 交互：点击和hover时，箭头灰色边框变深；点击这个“向右箭头”，整个笔记区域会向右收缩；
            • 笔记区域展开悬浮按钮：笔记区域收缩之后出现悬浮的“笔记图标”的气泡，点击之后笔记区域会从左向右展开；
            • 笔记区域内容容器：
                ◦ 用户点击AI查询卡片时生成的笔记内容，笔记内容以卡片形式展示来笔记区域内；
        ii. 展示和退出：
            • 当这个播客中没有对应任何一条笔记元素的时候，笔记区域默认不展开（也就是初始状态为不展开，不展示收缩的过程），但是会保留一个悬浮的笔记图标的气泡，点击之后笔记区域会从左向右展开；笔记图标hover/点击时，背景颜色变成加深的灰色；
            • 当页面上至少有1条笔记元素时，笔记区域默认从左至右展开并且保持展开状态；
            • 如果用户主动收起笔记区域，则除非用户主动展开笔记区域，笔记区域维持收缩状态；
            • 当笔记区域收缩或者展开时，英文字幕区域自适应展示；
        iii. 右侧笔记区域边栏可以一键收起：收起时，如果hover左侧字幕划线部分，对应笔记会以卡片形式展示在划线部分附近；右侧笔记边栏也可以点击展开；
    h. 笔记卡片：
        i. 笔记卡片的展示位置：
            (1) 用户点击“笔记图标之后”，生成一个笔记卡片，每条笔记卡片对应一条划线源，默认笔记卡片的顶部在用户的“划线源”顶部上面24px的位置，展示在右侧“笔记区域内部”，距离左右边缘24px。
            (2) 【todo】如果多个笔记卡片展示在笔记区域内产生了交叠，则怎么设计交互？
                在右侧笔记卡片重叠的时候，如果点击笔记卡片容器，会让被点击笔记卡片容器上浮到最上方展示；
        ii. 笔记卡片的宽高：
            (1) 每条笔记卡片对应一条划线源，默认笔记卡片的顶部与用户的“划线源”对齐，笔记卡片的高度最小为40px，最大为用户屏幕的一半；
            (2) 如果需要展示的内容高度超过用户屏幕的一半，则出现垂直方向的滚动条，允许用户上下滚动来浏览卡片内容。用户鼠标处于笔记卡片容器区域内滚动鼠标，不会导致整个播客学习页面一起滚动。
        iii. 数据：
            (1) 每条笔记和划线源一一关联，这样要求用户划线内容被储存下来并且关联笔记数据；每条笔记数据需要展示在划线源同等高度的位置，这要求用户划线的位置也被储存下来并且关联笔记数据；
            (2) 每条笔记数据包含创建用户（用一个图标mock用户的头像来表示）、创建时间、和笔记内容；
            (3) 每条笔记数据是按照播客文件分类的，也就是笔记数据也需要关联对应的播客episode和episode对应的英文字幕文件；
            (4) 现在我要做一个我本地调试的demo，没有远程的服务器，可以用本地电脑当成服务器，你作为一个资深工程师，帮我设计一下数据格式；
            (5) 每条笔记是储存在用户本地文件中；用户下次打开界面的时候会自动从本地加载笔记数据；
        iv. 笔记卡片结构：
            (1) 请先改变笔记卡片的结构来模拟界面效果，此时描述的任何界面按钮都先不用绑定交互逻辑；
            (2) 笔记卡片拥有标题栏、内容区：
            (3) 笔记卡片标题栏：
                ① 笔记卡片标题栏常驻，如果笔记卡片内容过长产生了滚动条，则滚动不影响标题栏的展示；
                ② 标题栏左侧：创建此条笔记的用户头像，demo阶段mock数据展示；
                ③ 标题栏头像右侧24px处：一个edit图标；
                ④ 标题栏右侧：垃圾桶图标；
            (4) 内容区：
                ① 标题栏下方是笔记内容区域，笔记卡片的内容需要自动换行；
                ② 笔记内容，也就是笔记数据content的内容，支持最小可行的排版：
                    1) 支持enter键入换行
                    2) 支持**语法加粗
                    3) 其他均会使用文本显示，不支持复杂的排版，会过滤，防止js注入；
                    4) 允许链接吗？如果输入链接是什么表现？
            (5) 交互：
                ① 单击笔记卡片容器：笔记卡片对应的“划线源容器”闪烁一下；
                ② 单击笔记标题栏按钮：
                    1) 单击edit图标：笔记内容区域变成可以编辑态，用户可以编辑笔记内容区域文字内容，用户编辑之后，如果单击笔记卡片容器之外任何地方，则此次修改会被提交，更新本地服务器json文件和笔记卡片内容；
                    2) 单击垃圾桶图标：
                        a) 用户屏幕正中弹出“删除笔记确认弹框”，弹框message显示“确认删除笔记？”，弹框下面的按钮为“确认”和“取消”；无默认选项；在这个弹框出现的时候，弹框后面的界面展示灰白色蒙层效果，如果用户没有点击“确认”和“取消”按钮，则用户点击其他任何地方都无效，只会让“删除笔记确认弹框”抖动一下要求用户确认操作；
                        b) 如果用户点击“取消”，“删除笔记确认弹框”和蒙层效果消失，用户恢复对界面的控制，没有任何其他改变发生；
                        c) 如果用户点击“确认”，“删除笔记确认弹框”和蒙层效果消失，用户恢复对界面的控制，且这一条笔记数据被删除，注意这个删除包括：笔记卡片、下划线效果、本地json数据；
        6.3. 后端总逻辑
音频文件、对应的字幕文件和字幕文件产生的笔记信息，需要一一关联，这样在切换音频文件的时候，字幕文件和笔记卡片才能够跟随切换
笔记卡片始终跟随字幕文件

    6.4. 其他交互原则
    a. 弹框层级逻辑：弹框需要点击越多的层级，则其z-index越高，越深层级的弹框越出现在上方；

7. 数据需求
7.1. 数据结构设计
7.1.1. 音频文件分块+字幕识别
file_hash_index.json - 文件哈希索引
{
  "audio_md5_hash": {
    "path": "uploads/audio_1234567890_example.mp3",
    "type": "audio",
    "original_filename": "example.mp3", 
    "timestamp": 1234567890,
    "duration": 600,
    
    "episode_id": "local-episode-audio_md5_hash",
    "legacy_id": "local-audio-example",
    
    "recognition": {
      "enabled": true,
      "needs_segmentation": true,
      "status": "pending|processing|completed|failed",
      "started_at": null,
      "completed_at": null,
      "progress_percentage": 0,
      "error_message": null,
      "profiles": {}  // 支持多配置版本
    },
    
    "transcript": {
      "transcript_id": "transcript-audio_md5_hash",
      "transcript_hash": null,
      "transcript_path": null,
      "file_size": null,
      "cue_count": 0,
      "generated_at": null
    },
    
    "segments": {
      "enabled": true,
      "segment_duration": 180,
      "total_segments": 4,
      "segments_dir": "uploads/segments/audio_md5_hash/",
      "completed_segments": 0,
      "segments_list": [
        {
          "segment_id": "segment_001",
          "segment_index": 0,
          "filename": "segment_001.mp3",
          "path": "uploads/segments/audio_md5_hash/segment_001.mp3",
          "file_hash": "segment_001_md5",
          "start_time": 0,
          "end_time": 180,
          "duration": 180,
          "status": "pending|processing|completed|failed",
          "transcript_data": null,
          "cue_id_range": {
            "start_cue_id": 0,
            "end_cue_id": 0
          },
          "error_message": null,
          "recognized_at": null
        }
      ]
    },
    
    "related_files": {
      "notes_count": 0,
      "notes_file": "lenney's_podcast_test/notes.json"
    }
  }
}文件储存结构
uploads/
├── audio_1234567890_example.mp3          # 原始音频
├── transcripts/
│   └── audio_hash/
│       └── profile_key.json              # 全量字幕
│       └── profile_key/
│           ├── segment_001.json           # 分段字幕
│           └── segment_002.json
└── segments/
    └── audio_hash/                       # 分段音频目录
        ├── segment_001.mp3
        └── segment_002.mp3流程
pending → processing → completed
  ↓           ↓
failed ← processing

7.1.2. 字幕文件：
对内使用自定义json格式，对外允许用户上传？普通字幕格式，然后需要转化为内部的json格式；
• 自定义json
下面是我为你设计的、推荐在整个项目内部使用的JSON文件结构。整个文件是一个对象，包含一些元数据和一个核心的 cues 数组。
文件名示例： my_podcast_transcript.json
### 1. 字幕文件格式 (transcript-*.json)

```json
{
  "metadata": {
    "episodeTitle": "Anthropic co-founder AGI predictions, leaving OpenAI, what keeps him up at night  Ben Mann",
    "audioFileName": "202508091059-mini.mp3",
    "language": "en-US",
    "transcribedAt": "2025-08-09T18:36:26Z",
    "showName": "Lenny's Podcast"
  },
  "cues": [
    {
      "id": 0,
      "start": 0.28,
      "end": 2.22,
      "speaker": "Lenny",
      "text": "Ben, thank you so much for being here."
    },
    {
      "id": 1,
      "start": 4.14,
      "end": 5.41,
      "speaker": "Ben",
      "text": "Thanks for having me. Great to be here, Lenny."
    }
  ]
}
```

### 2. 字段说明

#### 元数据 (Metadata)
| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `episodeTitle` | String | 单集标题 | `"Anthropic co-founder AGI predictions..."` |
| `audioFileName` | String | 对应的音频文件名 | `"202508091059-mini.mp3"` |
| `language` | String | 语言代码 | `"en-US"` |
| `transcribedAt` | String | 转录时间（ISO格式） | `"2025-08-09T18:36:26Z"` |
| `showName` | String | 播客节目名称 | `"Lenny's Podcast"` |

#### 字幕片段 (Cue)
| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `id` | Number | 片段唯一ID | `0` |
| `start` | Number | 开始时间（秒） | `0.28` |
| `end` | Number | 结束时间（秒） | `2.22` |
| `speaker` | String | 说话人标识 | `"Lenny"` 或 `"SPEAKER_01"` |
| `text` | String | 转录文本内容 | `"Ben, thank you so much for being here."` |

### 3. 字幕文件类型

#### 类型1：人工转录格式
- **文件示例**: `transcript-gemini2.5.json`
- **特点**: 
  - 说话人使用真实姓名（如 "Lenny", "Ben"）
  - 文本质量较高，包含标点符号
  - 时间戳精确到小数点后2位

#### 类型2：自动转录格式
- **文件示例**: `003_cues.json`
- **特点**:
  - 说话人使用通用标识（如 "SPEAKER_01", "SPEAKER_02"）
  - 文本可能包含转录错误
  - 时间戳精确到小数点后3位
  - 包含完整的metadata结构，与人工转录格式保持一致




7.2. 数据存储（数据库结构、字段说明）  
7.3. 数据输出（报表、API接口等）
8. 附录
8.1. 相关文档
1. 落地页设计宣传口设计：https://www.kdocs.cn/l/ckBhqM65syO4
2. README：
3. GitHub地址：
4. 开发技术文档：
8.2. todo：
1. 安全性风险检查，防止js注入
2. 图标视觉效果统一
3. 修改为本地技术栈，毕竟我本人并不想要开数据库
4. 基础的测试用例生成，用来保证主要功能不崩的
5. 其他端开发
8.3. 总结产品设计的经验：
界面描述遵循的信息是：界面位置、界面元素、界面元素互动逻辑（默认逻辑、正常交互主流程（元素的出现、退出）、边界/极值/错误值情况、中断之后恢复情况）、界面按钮底下控制的数据流动逻辑
某个组件需要分析的内容：
• 正常交互流程：出现、退出、运动规则、可交互行为、交互状态确认信息（比如成功了的话要加成功的提示条）
• 组件的样式组织：
    ◦ 边缘情况：loading页面、报错页面、确认成功页面
    ◦ 容器本身的样式：长/宽/高，边框，填充，三态（默认、hover、选中）
    ◦ 容器内容的展示：字体大小/颜色/类型，行距/段后距/缩进、换行行为
• 组件背后的数据流设计：
    ◦ 增（获取、清洗）
    ◦ 删
    ◦ 改
    ◦ 查
    ◦ 展示
